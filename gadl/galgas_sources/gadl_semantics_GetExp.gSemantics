semantics gadl_semantics_GetExp:
  import "gadl_options.gOption" ;
  import "gadl_variable.gSemantics" ;
  import "gadl_semantics.gSemantics";
  import "gadl_varIdfStruct.gSemantics";
  import "gadl_semantics_AST_expression.gSemantics";
  import "gadl_expression_functions.gSemantics"; #nbBitsToCodeSigned
  import "gadl_semantics_expression.gSemantics";
  import "gadl_semantics_expression_eval.gSemantics";


# readers:
#  * getExp for ASTExpression, to get the corresponding expression.
#  * getExp for ASTExpressionlist
# method:
#  * @parameterDefList checkParams: used in function calls.
# routine:
# checkCorrectAssignType -> check correct types in assignment. TODO, only partial.
#
## also basic functions, to check for data coherency for binary ops.
# * typeMult
# * typeDiv
# * typeSub
# * typeAdd
# * typeShift
# * typeCompare
# * typeBin
# * typeBool
# * typeCat
#
# * checkNoVoid -> expression with 'u0' or s0/f0 not allowed

# * fieldListFromAST get a fieldList from its AST.

#------------------------------------------------------------------------------
# Type verification.
#------------------------------------------------------------------------------

routine checkNoVoid
  ?? @varBaseType type
:
  if [type isVoid] then
    error [type location]: "The expression should not return void";
  end if;
end routine;

#multiplication: sum of sizes. Sign changed.
function typeMult
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  @varKind leftKind  := [leftType  kind];
  @varKind rightKind := [rightType kind];
  #check for unsigned or signed types.
  if (leftKind  == [@varKind signed] | leftKind  == [@varKind unsigned]) &
     (rightKind == [@varKind signed] | rightKind == [@varKind unsigned]) then
    @varKind kind := [leftType kind];
    if [leftType kind] != [rightType kind] then #only signed and unsigned here.
      kind := [@varKind signed]; #unsigned by signed gives signed result.
    end if;
    outType := [@varBaseType new !kind ![leftType size]+[rightType size] ![leftType location]];
  else
    if [leftType kind] == [@varKind float] | [rightType kind] == [@varKind float] then 
      error [leftType location]: "internal error: multiply float not implemented." :outType;
    elsif [leftType kind] == [@varKind custom] | [rightType kind] == [@varKind custom] then
      error [leftType location]: "cannot multiply a custom value." :outType;
    else
      error [leftType location]: "internal error: unknown kind." :outType;
    end if;
  end if;
end function;

#multiplication: sum of sizes. Sign changed.
function typeDiv
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  @varKind leftKind  := [leftType  kind];
  @varKind rightKind := [rightType kind];
  #check for unsigned or signed types.
  if (leftKind  == [@varKind signed] | leftKind  == [@varKind unsigned]) &
     (rightKind == [@varKind signed] | rightKind == [@varKind unsigned]) then
    @varKind kind := [leftType kind];
    if leftKind != rightKind then #only signed and unsigned here.
      error [leftType loc] : "Divide signed and unsigned expressions";
      message "left  expression type is ".[leftKind msg]."\n";
      message "right expression type is ".[rightKind msg]."\n";
    end if;
    outType := leftType;
  else
    if [leftType kind] == [@varKind float] | [rightType kind] == [@varKind float] then 
      error [leftType location]: "internal error: float division not implemented." :outType;
    elsif [leftType kind] == [@varKind custom] | [rightType kind] == [@varKind custom] then
      error [leftType location]: "cannot multiply a custom value." :outType;
    else
      error [leftType location]: "internal error: unknown kind." :outType;
    end if;
  end if;
end function;

function typeSub
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  if [leftType kind] != [rightType kind] then
    error [leftType loc] : "substract expressions of different kinds (signed/unsigned/float)";
    message "left  expression type is ".[[leftType kind] msg]. "(".[leftType string]. ")\n";
    message "right expression type is ".[[rightType kind] msg]."(".[rightType string].")\n";
  end if;
  if [leftType kind] == [@varKind unsigned] then #unsigned
    outType := leftType;
  elsif [leftType kind] == [@varKind signed] then #signed.
    if [leftType size] > [rightType size] then  #max of the 2 operands
      outType := [@varBaseType new ![leftType kind] ![leftType size] ![leftType loc]];
    else
      outType := [@varBaseType new ![leftType kind] ![rightType size] ![leftType loc]];
    end if;
  elsif [leftType kind] == [@varKind float] then #float
    error [leftType location]: "internal error, not yet implemented with floats" :outType;
  else 
    error [leftType location]: "No substraction with custom types." :outType;
  end if;
end function;

function typeAdd
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  if [leftType kind] != [rightType kind] then
    error [leftType loc] : "add expressions of different kinds (signed/unsigned/float)";
    message "left  expression type is ".[[leftType kind] msg]. "(".[leftType string]. ")\n";
    message "right expression type is ".[[rightType kind] msg]."(".[rightType string].")\n";
  end if;
  if ([leftType kind] == [@varKind unsigned]) |
     ([leftType kind] == [@varKind signed]) then
    if [leftType size] > [rightType size] then
      outType := [@varBaseType new ![leftType kind] ![leftType size]+1 ![leftType loc]];
    else
      outType := [@varBaseType new ![leftType kind] ![rightType size]+1 ![leftType loc]];
    end if;
  elsif [leftType kind] == [@varKind float] then #float
    error [leftType location]: "internal error, not yet implemented with floats" :outType;
  else 
    error [leftType location]: "No addtions with custom types." :outType;
  end if;
end function;

function typeShift
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  ?? @expression expRight
  ?? @symbolValueMap symbolMap
  ?? @bool shiftLeft
  -> @varBaseType outType
:
  #check right type (shift) is unsigned.
  if [rightType kind] != [@varKind unsigned] then
    error [rightType location]:"the shift value should be an unsigned value";
  end if;
  #check left type is not float.
  if ([leftType kind] == [@varKind unsigned]) |
     ([leftType kind] == [@varKind signed]) then
    #try to eval right exp to get the correct size.
    @bool ok := true;
    @uint64 shiftVal := 0L;
    @uint nbBits := 0;
    [[expRight eval !symbolMap] getUVal ?shiftVal ?ok];
    if ok then #shift value is statically known.
      if shiftLeft then #<<
        nbBits :=  [leftType size] + shiftVal;
      else #>>
        nbBits :=  [leftType size] - shiftVal;
      end if;
    else
      nbBits := [leftType size];
      if shiftLeft & [option gadl_options.warnIfResultMayBeTruncated value] then #<<
        warning [rightType location]:"cannot eval right value in shift operation. ".
                                    "Type of Right expression may be unappropriate";
      end if;
    end if;
    outType := [@varBaseType new ![leftType kind] !nbBits ![leftType location]]; 
  else
    error [leftType location]: "Left part expression in shift should be either a signed or unsigned value.":outType;
  end if;
end function;


function typeCompare
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  if ([leftType kind] != [rightType kind]) then
    warning [leftType location] : "compare expressions of different kind (unsigned, signed, float)";
  end if;
  outType := [@varBaseType new ![@varKind unsigned] !1 ![leftType location]]; #u1
end function;

function typeBin
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  if (([leftType kind] == [@varKind unsigned]) | ([leftType kind] == [@varKind signed])) then
    if ([leftType kind] != [rightType kind]) then
      error [leftType location]  : "left and right operands have not the same kind (unsigned/signed/float..).";
      error [rightType location]  : "left and right operands have not the same kind (unsigned/signed/float..).";
    end if;
    @uint nbBits;
    # get the max.
    if [leftType size] > [rightType size] then nbBits := [leftType size];
    else nbBits := [rightType size];
    end if;
    outType := [@varBaseType new ![leftType kind] !nbBits ![leftType location]];
  else
    error [leftType location]:"can use binary operations only on integers, types in the operation are ".
                              [leftType string]." and ".[rightType string].".":outType;
  end if;
end function;

function typeBool
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  [leftType checkBool];
  [rightType checkBool];
  outType := [@varBaseType new ![leftType kind] !1 ![leftType location]];
end function;

function typeCat
  ?? @varBaseType leftType
  ?? @varBaseType rightType
  -> @varBaseType outType
:
  if [leftType kind] != [rightType kind] then
    error [leftType  location]:"cannot concatenate expressions of different kinds";
    error [rightType location]:"cannot concatenate expressions of different kinds" : outType;
  else
    outType := [@varBaseType new ![leftType kind] ![leftType size]+[rightType size] ![leftType location]];
  end if;
end function;
#------------------------------------------------------------------------------
# Field related methods.
#------------------------------------------------------------------------------

#return the field Size, in bits.
reader @fieldList fieldsize
  ?? @symbolValueMap symbolMap
  ->  @uint size
:
  @uint max := 64;
  @bool unknown := false;
  size := 0;
  foreach selfcopy (@expression expFrom @expression expTo * @bool only1Exp) while not unknown do
    if only1Exp then
      size := size + 1; #no pb: One expression -> one bit selected.
    else
      #TODO: should init vars, because no 'eval' nor 'getUVal' yet.
      @uint64 rangeFrom;
      @bool ok := true;
      [[expFrom eval !symbolMap] getUVal ?rangeFrom ?ok];
      if ok then #can evaluate 'from'
        @uint64 rangeTo;
        [[expTo eval !symbolMap] getUVal ?rangeTo ?ok];
        if ok then #can evaluate 'to'
          size := size + [rangeFrom uint]-[rangeTo uint]+1;
        end if;
      end if;
      if not ok then 
        unknown := true;
        size := max;
      end if;
    end if;
  end foreach;
end reader;
#------------------------------------------------------------------------------
#-- reader that generates the semantic (decorated) structure
#------------------------------------------------------------------------------

reader @ASTExpressionlist getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expressionlist expList
:
  expList := [@expressionlist emptyList];
  foreach selfcopy(@ASTExpression ASTexp) do
    expList += ![ASTexp getExp !ctx !symbolMap !idfStruct];
  end foreach;
end reader;


abstract reader @ASTExpression getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
;

override reader @ASTIntConst getExp
  ?? @expressionContext unused ctx
  ?? @symbolValueMap unused symbolMap
  ?? @varIdfStruct unused idfStruct
  -> @expression exp
:
  if kind == [@varKind unsigned] & negative == true then
    error loc: "the value is negative, but declared as unsigned!";
  end if;
  @uint nbBits;
  if kind == [@varKind signed] then
    nbBits := nbBitsToCodeSigned[!value];
  else
    nbBits := nbBitsToCodeUnsigned[!value];
  end if;
  #nb bits must be >0, when used in the expression (s8)(0)
  if nbBits == 0 then nbBits := nbBits + 1; end if;
  @varBaseType outType := [@varBaseType new !kind !nbBits !loc];
  exp := [@expIntConst new !outType !value !negative] ;
end reader;


override reader @ASTExpInstructionSize getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap unused symbolMap
  ?? @varIdfStruct unused idfStruct
  -> @expression exp
:
  if ctx != [@expressionContext timing] then
    error loc : "The 'instruction size' expression should only be used in a timing view. Here is ".[ctx msg];
  end if;
  @varBaseType outType := [@varBaseType new ![@varKind unsigned] !8 !loc]; #instruction size -> u8
  exp := [@expInstructionSize new !outType];
end reader;

override reader @ASTExpInstructionAddress getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap unused symbolMap
  ?? @varIdfStruct unused idfStruct
  -> @expression exp
:
  if ctx != [@expressionContext syntaxView] & ctx != [@expressionContext behavior] then
    error loc : "The 'instruction address' expression should only be used in a syntax or behavior view (ISA). Here is ".[ctx msg];
  end if;
  @varBaseType outType := [@varBaseType new ![@varKind unsigned] !32 !loc]; #instruction address -> u32
  exp := [@expInstructionAddress new !outType];
end reader;

override reader @ASTCast getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
:
  @expression expCasted := [ASTexp getExp !ctx !symbolMap !idfStruct];
  if [toType size] == 0 then
    error loc: "The type should have a size > 0 in the cast.\n";
  end if;
  exp := [@expCast new !toType !expCasted];
end reader;

#this function remove the tabular to extract the 'base' type
#the type returned should be either varBaseType or varStructType
function removeTabInIdf
  ?? @varAbstractType type
  -> @varAbstractType typeWithoutTab
:
  typeWithoutTab := type;
  cast type
  when == @varTabularType vtt : #tabular type.
    typeWithoutTab := removeTabInIdf[![vtt type]];
  else
  end cast;
  #check;
  #if typeWithoutTab is @varTabularType then
  #  error here: "internal error in function removeTabInIdf";
  #end if;
end function;

#The type is unknown only for the first item of an idf list.
routine handleUnknownType
  ?? @lstring idf 
  ?? @idfItemType idfItemType 
  ?? @varIdfStruct idfStruct
  ?! @bool isConst  
  ?! @idfType detectedType
  ?? @bool lastIdf
  ?! @lstring typeName #name of the item or struct detected (to further search into structures).
  ?! @varAbstractType outType
  ?! @bool shouldStop
  ?! @string prefix
  ?! @string suffix
  ?! @parameterDefList paramDef #param definition to check.
  ?! @location locDef #location of parameters to check (if any).
:
  detectedType := [@idfType unknown]; #it should already be set like this.
  if [idfStruct->varMap hasKey ![idf string]] then
    @varAbstractType type;
    @varClass varClass;
    [idfStruct->varMap searchKey !idf ?type ?isConst ?varClass ?*];
    @varAbstractType typeWithoutTab := removeTabInIdf[!type];
    cast typeWithoutTab
    when == @varStructType vst : #struct type.
      #Ok item is a struct.
      typeName := [vst typeName];
      detectedType := [@idfType structMember];
      if not lastIdf then
        suffix := ".";
      end if;
      shouldStop := false;
      outType := typeWithoutTab;
    when == @varBaseType :
      #Ok, item is a base type (or a tab of base type).
      switch varClass
      when localVar,field:
        switch idfItemType
        when basic   :
          shouldStop := true;
          detectedType := [@idfType localVar];
          outType := typeWithoutTab;
        when tabular :
          shouldStop := true;
          detectedType := [@idfType tabularAccess];
          outType := typeWithoutTab;
        when functionCall:
          error idf: "The identifier is set as a function call, while it is a local variable";
        end switch;
      when programCounter,GPR,SFR: #varMap reported a register.
        switch idfItemType
        when basic   :
          detectedType := [@idfType registerAccess];
          if not lastIdf then #case for a register slice.
            suffix := "_";
          end if;
          shouldStop := false;
          prefix := idfStruct->idfPrefixCore;
          if idfStruct->assign then prefix .= "set"; end if;
          outType := typeWithoutTab;
        when tabular : error idf: "Cannot use a register as a tabular.";
        when functionCall: error idf: "The register is used like a function.";
        end switch;
      when registerSlice,device:
        #only the reg_slice is in the varMap, and idf here is only 'reg' (from 'reg.slice').
        error idf: "internal error got a register slice here, not allowed";
      end switch;
    when == @varDeviceType vdt:
      #got a peripheral access -> return the type of the device (peripheral name)
      typeName := [vdt typeName];
      detectedType := [@idfType periphCall];
      shouldStop := false;
      suffix := "->";
    else
      error here : "internal error: invalid type in handleIdf";
      #ok := false;
    end cast;
  elsif [idfStruct->componentMap hasKey ![idf string]] then
    #try in the component Map
    detectedType := [@idfType componentCall];
    prefix := idfStruct->idfPrefixCore;
    shouldStop := false;
    suffix := "_";
  elsif [idfStruct->memSpaceMap hasKey ![idf string]] then
    #try in the memory map?
    detectedType := [@idfType memoryAccess];
    prefix := idfStruct->idfPrefixCore;
    shouldStop := false;
    suffix := "_";
  elsif [idfStruct->ASTperipheralMap hasKey ![idfStruct->currentPeriphName string]] then
    #current peripheral. Can call a method.
    [idfStruct->ASTperipheralMap searchKey !idfStruct->currentPeriphName ?* ?*
       ?@ASTFunctionMap ASTFunctionMap
       ?* ?* ?* ?* ?*];
    if [ASTFunctionMap hasKey ![idf string]] then
      [ASTFunctionMap searchKey !idf ?paramDef ?outType ?*];
      locDef := [ASTFunctionMap locationForKey ![idf string]];    
      shouldStop := true;
      isConst := true;
      detectedType := [@idfType periphCall];
      prefix := "method_";
    #should not take care of peripherals'registers here, because they are in the varMap
    #(current peripheral).
    else
      error idf: "The identifier ".idf." is not found in the current peripheral (".idfStruct->currentPeriphName.")";
    end if;
  end if;
  #else detected type not modified (still unknown) -> will report an error.
end routine;

routine handleStructMember
  ?? @lstring idf 
  ?? @varIdfStruct idfStruct
  ?! @idfType detectedType
  ?? @bool lastIdf
  ?! @lstring typeName #name of the item or struct detected (to further search into structures).
  ?! @varAbstractType outType
  ?! @string suffix
  ?! @bool shouldStop
:
  #it should be defined as a member.
  @typedefMemberMap memberMap;
  [idfStruct->typedefMap searchKey !typeName ?memberMap];
  #ok, we check that current item is a member.
  @varAbstractType memberType;
  [memberMap searchKey !idf ?memberType];
  @varAbstractType memberTypeWithoutTab := removeTabInIdf[!memberType];
  outType := memberTypeWithoutTab;
  cast memberTypeWithoutTab
  when == @varStructType vst : #struct type.
    shouldStop := false;
    #nested struct members.
    typeName := [vst typeName];
    detectedType := [@idfType structMember];
    if not lastIdf then
      suffix := ".";
    end if;
  else
    #not a struct. It should be the last item.
    shouldStop := true;
    detectedType := [@idfType structMember];
  end cast;
end routine;

routine handleRegisterType
  ?? @idfItemList currentItemList #items already parsed.
  ?? @lstring idf 
  ?? @varIdfStruct idfStruct
  ?! @bool isConst  
  ?! @idfType detectedType
  ?! @lstring typeName #name of the item or struct detected (to further search into structures).
  ?! @varAbstractType outType
  ?! @bool shouldStop
:
  @idfItemList currentItemListCopy := currentItemList;
  [!?currentItemListCopy popLast ?@lstring regName ?* ?* ?* ?* ?*];
  #we detected a register access, while it may be a register slice access.
  @string regSlice := getRegSliceName[![regName string] ![idf string]];
  if [idfStruct->varMap hasKey !regSlice] then #register slice inside varMap
    #message "I've just discover a reg slice ".regSlice."\n";
    #got a register slice.
    [idfStruct->varMap searchKey ![@lstring new !regSlice !here] ?outType ?isConst ?@varClass varClass ?*];
    if varClass != [@varClass registerSlice] then
      error idf : "internal error: detect a register slice, while variable map does not have the same type";
    end if;
    shouldStop := true;
    detectedType := [@idfType registerBitField];
  elsif [idfStruct->ASTperipheralMap hasKey ![typeName string]] then #register slice inside a peripheral
    [idfStruct->ASTperipheralMap searchKey !typeName ?* ?* ?* ?* ?* ?* ?@varMap regMap ?*];
    [regMap searchKey ![@lstring new !regSlice !here] ?outType ?isConst ?@varClass varClass ?*];
    if varClass != [@varClass registerSlice] then
      error idf : "internal error: detect a register slice, while variable map does not have the same type";
    end if;    
    detectedType := [@idfType registerBitField];    
    shouldStop := true;
  else
    error idf : "Unknown identifier ".[currentItemList string].".".[idf string];
  end if;
end routine;

routine handleComponentType
  ?? @idfItemList currentItemList #items already parsed.
  ?? @lstring idf 
  ?? @varIdfStruct idfStruct
  ?! @bool isConst  
  ?! @varAbstractType outType
  ?! @bool shouldStop
  ?! @parameterDefList paramDef #param definition to check.
  ?! @location locDef #location of parameters to check (if any).
:
  @idfItemList currentItemListCopy := currentItemList;
  [!?currentItemListCopy popLast ?@lstring compName ?* ?* ?* ?* ?*];
  #message "I've just discover a component ".compName .".".idf."\n";
  [idfStruct->componentMap searchKey !compName ?@functionMap methodMap];
  [methodMap searchKey !idf ?paramDef ?outType ?*];
  locDef := [methodMap locationForKey ![idf string]];
  shouldStop := true;
  isConst := true;
end routine;

routine handleMemoryType
  ?? @idfItemList currentItemList #items already parsed.
  ?? @lstring idf 
  ?? @varIdfStruct idfStruct
  ?! @bool isConst  
  ?! @varAbstractType outType
  ?! @bool shouldStop
  ?! @parameterDefList paramDef #param definition to check.
  ?! @location locDef #location of parameters to check (if any).
:
  @idfItemList currentItemListCopy := currentItemList;
  [!?currentItemListCopy popLast ?@lstring memSpaceName ?* ?* ?* ?* ?*];
  @functionMap methodMap;
  [idfStruct->memSpaceMap searchKey !memSpaceName ?* ?methodMap ?* ?*];
  locDef := [idfStruct->memSpaceMap locationForKey ![memSpaceName string]];
  [methodMap searchKey !idf ?paramDef ?outType ?*];
  shouldStop := true;
  isConst := true;
end routine;

routine handlePeriphCallType
  ?? @lstring idf 
  ?? @idfItemType unused idfItemType 
  ?? @varIdfStruct idfStruct
  ?! @bool isConst  
  ?! @idfType detectedType
  ?? @bool lastIdf
  ?! @lstring typeName #name of the item or struct detected (to further search into structures).
  ?! @varAbstractType outType
  ?! @bool shouldStop
  ?! @string prefix
  ?! @string suffix
  ?! @parameterDefList paramDef #param definition to check.
  ?! @location locDef #location of parameters to check (if any).
:
  @ASTregisterPeriphDefMap ASTregisterPeriphDefMap;
  @ASTFunctionMap ASTFunctionMap;
  [idfStruct->ASTperipheralMap searchKey !typeName ?* ?ASTregisterPeriphDefMap ?ASTFunctionMap ?* ?* ?* ?* ?*];
  #search for a register.
  if [ASTregisterPeriphDefMap hasKey ![idf string]] then
    [ASTregisterPeriphDefMap searchKey !idf ?* ?* ?* ?* ?outType];
    detectedType := [@idfType registerAccess];
    if not lastIdf then #case for a register slice.
      suffix := "_";
    end if;
    isConst := false;
    shouldStop := false;
    if idfStruct->assign then prefix .= "set"; end if;
  elsif [ASTFunctionMap hasKey ![idf string]] then
    #message "This is a function call\n";
    [ASTFunctionMap searchKey !idf ?paramDef ?outType ?*];
    locDef := [ASTFunctionMap locationForKey ![idf string]];
    shouldStop := true;
    isConst := true;
    prefix := "method_";
  else
    error idf: "in peripheral ".[typeName string].", the identifier ".idf." is not found";
  end if;
end routine;

routine handleIdf 
  ?? @idfItemList currentItemList #items already parsed.
  ?? @lstring idf                 #current idf to parse
  ?? @idfItemType idfItemType     #item type (from AST)
  ?? @varIdfStruct idfStruct      #all symbol maps
  ?? @expressionContext unused ctx
  ?! @idfType detectedType        #current detected type (unknown for the first item)
  ?! @bool isConst                #can be written? (assignment check)
  !  @varAbstractType outType     #returned type
  ?? @bool lastIdf                #is it the last item (to differentiate register from reg slice, manage suffix)
  ?! @idfItemSpecType unused specificType
  ?! @string prefix               #for code generation
  ?! @string suffix               #for code generation
  ?! @lstring typeName            #type detected in the previous item.
  !  @bool shouldStop             #the previous item should be the last of the list.
  ?! @parameterDefList paramDef   #param definition to check.
  ?! @location locDef             #location of parameters to check (if any).
:
  shouldStop := true; #default.
  outType := [@varBaseType new ![@varKind unsigned] !0 !here]; #dummy u0.
  switch detectedType
    when unknown          : #first pass
      handleUnknownType !idf !idfItemType !idfStruct !?isConst !?detectedType !lastIdf
                        !?typeName !?outType !?shouldStop !?prefix !?suffix !?paramDef !?locDef;
    when structMember     :
      handleStructMember !idf !idfStruct !?detectedType !lastIdf
                        !?typeName !?outType !?suffix !?shouldStop;
    
    when localVar,tabularAccess,registerBitField: 
      error here :"internal error: Identifier should not have more than 1 part here.";
    when registerAccess   :
      handleRegisterType !currentItemList !idf !idfStruct !?isConst !?detectedType
                         !?typeName !?outType !?shouldStop;
    when componentCall    :
      handleComponentType !currentItemList !idf !idfStruct !?isConst 
                          !?outType !?shouldStop !?paramDef !?locDef;    
    when periphCall       :
      handlePeriphCallType !idf !idfItemType !idfStruct !?isConst !?detectedType !lastIdf
                        !?typeName !?outType !?shouldStop !?prefix  !?suffix !?paramDef !?locDef;
    when memoryAccess     :
      handleMemoryType !currentItemList !idf !idfStruct !?isConst 
                       !?outType !?shouldStop !?paramDef!?locDef;
  end switch;
end routine;

override reader @ASTIdf getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
:
  #message "**************************************************************\n";
  #message [idfStruct string];
  #message "To parse : ". [idfList string]."\n";
  #the final type of idf (the one returned by the exp)
  @varAbstractType outType := [@varBaseType new ![@varKind unsigned] !0 !here]; #dummy u0.
  @idfType detectedType := [@idfType unknown];
  @bool isConst := false;
  @idfItemList itemList [emptyList];
  @bool shouldStop := false;
  @bool first := true;
  @lstring typeName := [@lstring new !"SHOULD-NOT-HAPPEN" !here];
  @parameterDefList paramDef [emptyList]; #param definition to check.
  @location locDef := here; #location of parameters to check (if any).
  @uint idfId := 0;
  @bool lastIdf := false;
  foreach idfList do
    #detect the last item
    idfId := idfId+1;
    lastIdf := (idfId == [idfList length]);
    if shouldStop then
      error idf: "The identifier cannot be determined (too long):".[idfList string];
    end if;
    #handle the idf
    @string prefix := "";
    @string suffix := "";
    @idfItemSpecType specificType := [@idfItemSpecType unknown];
    @lstring finalIdf := idf; #the idf that will be stored in expIdf.
    #handle parameters
    if first then
      first := false;
      #first pass is a little trickyâ€¦ Search in the varMap with the suffix
      #First, search using both prefix and suffix...
      finalIdf := [idfStruct getReplacedIdf ![idfStruct getIdfPrePost !idf]];
      handleIdf !itemList !finalIdf !type !idfStruct !ctx !?detectedType !?isConst ?outType !lastIdf
                !?specificType !?prefix !?suffix !?typeName ?shouldStop !?paramDef !?locDef;
      if detectedType == [@idfType unknown] then #not found
        #not found: try without the prefix -> fields.
        finalIdf := [idfStruct getReplacedIdf ![idfStruct getIdfPost !idf]];
        handleIdf !itemList !finalIdf !type !idfStruct !ctx !?detectedType !?isConst ?outType !lastIdf 
                  !?specificType !?prefix !?suffix !?typeName ?shouldStop !?paramDef !?locDef;
        if detectedType == [@idfType unknown] then #not found
          #then without anything.
          finalIdf := [idfStruct getReplacedIdf !idf];        
          handleIdf !itemList !finalIdf !type !idfStruct !ctx !?detectedType !?isConst ?outType !lastIdf
                    !?specificType !?prefix !?suffix !?typeName ?shouldStop !?paramDef !?locDef;
        end if;
      end if;
    else #not first
      handleIdf !itemList !finalIdf !type !idfStruct !ctx !?detectedType !?isConst ?outType !lastIdf
                !?specificType !?prefix !?suffix !?typeName ?shouldStop !?paramDef !?locDef;
    end if;
    #message "type detected is ".[detectedType string]." <--\n";
    #error detection
    if detectedType == [@idfType unknown] then #not found
      error idf: "The identifier cannot be determined: ".[idfList string];
      shouldStop := true;
    end if;
    #get parameters' expressions.
    @expressionlist paramList := [ASTparamList getExp !ctx !symbolMap !idfStruct];
    if [paramDef length] > 0 then #something to check
      [paramDef checkParams !paramList ![idf location] !locDef];
      #reinit params for next loop.
      paramDef := [@parameterDefList emptyList];
    end if;
    #add in the output itemList.
    itemList += !finalIdf !type !paramList !specificType !prefix !suffix;
  end foreach;
  @varAbstractType idfExpTypeWithLoc := [outType changeLoc !loc];
  exp := [@expIdf new !idfExpTypeWithLoc !itemList !detectedType !isConst];
end reader;

function fieldListFromAST
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  ?? @ASTfieldList astFList
  -> @fieldList flist
:
  flist := [@fieldList emptyList];
  foreach astFList (@ASTExpression expFrom @ASTExpression expTo @bool only1Exp) do
    flist += ![expFrom getExp !ctx !symbolMap !idfStruct] ![expTo getExp !ctx !symbolMap !idfStruct] ![expFrom loc] !only1Exp;
  end foreach;
end function;

override reader @ASTBitFieldOp getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
:
  @expression baseExp := [ASTexp getExp !ctx !symbolMap !idfStruct];
  @fieldList flist := fieldListFromAST[!ctx !symbolMap !idfStruct !astFList];
  #The type
  @varBaseType baseType := [[baseExp type] getBaseType];
  @varBaseType type := [@varBaseType new ![baseType kind] ![flist fieldsize !symbolMap] ![baseType location]];
  exp := [@expBitFieldOp new !type !baseExp !flist];
end reader;

override reader @ASTSliceFieldOp getExp
  ?? @expressionContext unused ctx
  ?? @symbolValueMap unused symbolMap
  ?? @varIdfStruct unused idfStruct
  -> @expression exp
:
  exp := [@expDummy new ![@varBaseType new ![@varKind unsigned] !1 !here] !"TODO ASTSliceFieldOp"];
end reader;

override reader @ASTUnaryOp getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
:
  @expression baseExp := [ASTexp getExp !ctx !symbolMap !idfStruct];
  if id == 0 then
    [[baseExp type] checkBool];
  end if;
  exp := [@expUnary new ![baseExp type] !baseExp !id];
end reader;

override reader @ASTBinaryBasicOp getExp
  ?? @expressionContext ctx
  ?? @symbolValueMap symbolMap
  ?? @varIdfStruct idfStruct
  -> @expression exp
:
  @expression expLeft := [ASTexpLeft getExp !ctx !symbolMap !idfStruct];
  @expression expRight := [ASTexpRight getExp !ctx !symbolMap! idfStruct];
  #ok, now, get the type size..
  #first, binary ops are restricted to basic types.
  @varBaseType baseTypeLeft  := [[expLeft  type] getBaseType];
  @varBaseType baseTypeRight := [[expRight type] getBaseType];
  checkNoVoid !baseTypeLeft;
  checkNoVoid !baseTypeRight;
  @varBaseType type;
  if    id == 0  then type := typeMult[!baseTypeLeft !baseTypeRight]; #*
  elsif id == 1  then type := typeDiv[!baseTypeLeft !baseTypeRight];  #/
  elsif id == 2  then type := typeDiv[!baseTypeLeft !baseTypeRight];  #%
  elsif id == 3  then type := typeAdd[!baseTypeLeft !baseTypeRight];  #+
  elsif id == 4  then type := typeSub[!baseTypeLeft !baseTypeRight];  #-
  elsif id == 5  then type := typeShift[!baseTypeLeft !baseTypeRight !expRight !symbolMap !false];  #>>
  elsif id == 6  then type := typeShift[!baseTypeLeft !baseTypeRight !expRight !symbolMap !true];   #<<
  elsif id == 7  then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #<
  elsif id == 8  then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #>
  elsif id == 9  then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #<=
  elsif id == 10 then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #<=
  elsif id == 11 then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #=
  elsif id == 12 then type := typeCompare[!baseTypeLeft !baseTypeRight]; ; #!=
  elsif id == 13 then type := typeBin[!baseTypeLeft !baseTypeRight]; ; #&
  elsif id == 14 then type := typeBin[!baseTypeLeft !baseTypeRight]; ; #^
  elsif id == 15 then type := typeBin[!baseTypeLeft !baseTypeRight]; ; #|
  elsif id == 16 then type := typeBool[!baseTypeLeft !baseTypeRight]; ; #&&
  elsif id == 17 then type := typeBool[!baseTypeLeft !baseTypeRight]; ; #^^
  elsif id == 18 then type := typeBool[!baseTypeLeft !baseTypeRight]; ; #||
  elsif id == 19 then type := baseTypeLeft; #ror 
  elsif id == 20 then type := baseTypeLeft; #rol
  elsif id == 21 then type := typeCat[!baseTypeLeft !baseTypeRight]; ; #cat
  else error [baseTypeLeft location]:"internal error: unknown id in ASTBinaryBasicOp":type;
  end if;
  exp := [@expBinary new !type !expLeft !expRight !id];
end reader;

#method related to function call.
#check parameters.
method @parameterDefList checkParams
  ?? @expressionlist expList
  ?? @location callLoc
  ?? @location defLoc  
:
  #first check lengths.
  if [expList length] != [selfcopy length] then
    @string str := "Bad number of arguments in the function call: ".[expList length]." arguments";
    str .= " are given, while the function requires ".[selfcopy length]." parameters";
    error defLoc: str;
    error callLoc: str;
  end if;
  #then iterate on each list
  foreach expList(@expression exp), selfcopy(@bool out @varAbstractType type @lstring name) do
    #check that expression fits
    checkCorrectAssignType !type !exp !name;
    #check that expression for an 'out' argument is only an idf.
    if out then
      if (exp is == @expIdf) then
      else
        error [[exp type] loc]: "The parameter ".[name string]." at ".[[name location] locationString].
                   " is an output argument. It must be called with an identifier only.";
      end if;
    end if;
  end foreach;
end method;

#Check that the type returned by the expression (fromType) is in phase with the type awaited ('ToType').
#TODO: may be a method from @varAbstractType?
routine checkCorrectAssignType
  ?? @varAbstractType toType
  ?? @expression exp
  ?? @lstring idf #used to know the name of the var assigned (error string).
:
  @varAbstractType fromType := [exp type];
  @string errorStr := "Try to assign expressions of different types, from ".[[fromType kind] msg];
  errorStr .= " to ".[[toType kind] msg]."(".idf.")";

  cast fromType
  when == @varBaseType vbt:
    if (toType is == @varBaseType) then
      if [fromType kind] == [toType kind] then
        @varBaseType toVbt := (cast toType : @varBaseType);
        #ok, to vars of the same kind. Check size.
        if [vbt size] > [toVbt size] then
          #too few.
          @uint vbtS := [vbt size];
          @uint toVbtS := [toVbt size];
          if [option gadl_options.warnIfResultMayBeTruncated value] then
            warning [idf location] : "Try to set a value of ".vbtS." bits into a variable of ".toVbtS."bits (".idf.")";
          end if;
        end if;
      else
        #just a warning here: unsigned with signed, ..
        warning [idf location] : errorStr;
      end if;
    else
      #error from varBaseType to other type.
      error [idf location] : errorStr;
    end if;
  when == @varStructType vst:
    if (toType is == @varStructType) then
      @varStructType toTypeStruct :=  (cast toType : @varStructType);
      if [[vst typeName] string] != [[toTypeStruct typeName] string] then
        error [idf location]: "try to assign a variable of type structure ".[[vst typeName] string]." to ".
          "an identifier of type ".[toTypeStruct string];
      end if;
    else
      error [idf location]: "try to assign a variable of type structure ".[[vst typeName] string]." to ".
          "an identifier that is not a structure.";
          log toType;
    end if;
  when == @varTabularType vtt:
    message "no checkCorrectAssignType for varTabularType implemented\n";
  else
    error [idf location]: "internal error in checkCorrectAssignType";
  end cast;
end routine;

end semantics ;
# vim:ft=ggs:ts=2:sw=2
