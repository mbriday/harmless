model hc12 {

default {
  instruction := 8             -- default instruction size
  --fetch := Fetcher.fetchCode() -- fetcher function
  fetch address := Mem.getRealAddress()
  program read  := Mem.programLoaderTranslation()
  big endian
}

component Mem {
  memory registers {
    width := 16
    address := \x0..\x7FF -- 2 kb of registers
    type := register

    register u16 GPAGE maps to \x10 -- Global page index
    register u8  RPAGE maps to \x16 -- RAM page index
    register u8  EPAGE maps to \x17 -- EEPROM Page index
    register u8  PPAGE maps to \x30 -- Program page index
  }
  program memory windowedEeprom {
    width := 16
    address := \x13_F000..\x13_FFFF -- 4kb
    type := ROM
  }
  program memory nonWindowedEeprom {
    width := 16
    address := \x0C00..\x0FFF -- 1kb
    type := ROM
  }
  memory windowedRAM {
    width := 16
    address := \xF_8000..\xF_FFFF -- 32kb
    type := RAM
  }
  memory nonWindowedRAM {
    width := 16
    address := \x2000..\x3FFF -- 8kb
    type := RAM
  }
  program memory firstUnpagedflash {
    width := 16
    address := \x4000..\x7FFF -- 16 kb of flash.
    type := ROM
  }
  program memory windowedFlash {
    width := 16
    address := \x78_0000..\x7F_FFFF -- 512 kb of flash.
    type := ROM
  }
  program memory secondUnpagedflash { --including interrupt vectors.
    width := 16
    address := \xC000..\xFFFF -- 16 kb of flash.
    type := ROM
  }

  u32 programLoaderTranslation(u32 linkerAddr)
  {
    u32 addr
    u16 baseAddr := (u16)(linkerAddr & \xFFFF) --TODO trouver le type.
    if((baseAddr >= \x8000) && (baseAddr < \xC000)) then --#flash
       addr := (linkerAddr{23..16} cat linkerAddr{13..0}) | \x400000
    elseif((baseAddr >=\x800) && (baseAddr < \x0C00)) then --eeprom
       addr := (linkerAddr{23..16} cat linkerAddr{9..0}) | \x100000
    else addr := linkerAddr
    end if
    return addr
  }

  -- used by to get the real address from the PC. This function is defined
  -- as "fetch address" in the default section.
  -- Here, only the Flash is taken into account.
  u24 getRealAddress(u16 addr)
  {
    -- description from MC9S12XDP512 Data Sheet, p.31
    u24 realAddr
    --if     addr >= \x0800 && addr < \x0c00 then realAddr := (EPAGE cat addr{9..0}) | \x100000
    --elseif addr >= \x1000 && addr < \x2000 then realAddr := RPAGE cat addr{11..0}
    if addr >= \x8000 && addr < \xC000 then realAddr := (PPAGE{7..0} cat addr{13..0}) | \x400000
    else realAddr := addr
    end if
    return realAddr
  }

  u8 memRead8(u16 addr)
  {
    -- description from MC9S12XDP512 Data Sheet, p.31
    u8 val
    if     addr < \x0800 then val := Mem.registers.read8(addr)
    elseif addr < \x0c00 then val := Mem.windowedEeprom.read8((EPAGE cat addr{9..0}) | \x100000)
    elseif addr < \x1000 then val := Mem.nonWindowedEeprom.read8(addr)
    elseif addr < \x2000 then val := Mem.windowedRAM.read8(RPAGE cat addr{11..0})
    elseif addr < \x4000 then val := Mem.nonWindowedRAM.read8(addr)
    elseif addr < \x8000 then val := Mem.firstUnpagedflash.read8(addr)
    elseif addr < \xC000 then val := Mem.windowedFlash.read8((PPAGE{7..0} cat addr{13..0}) | \x400000)
    elseif addr < \xFFFF then val := Mem.secondUnpagedflash.read8(addr)
    end if
    return val
  }

  u16 memRead16(u16 addr)
  {
    -- description from MC9S12XDP512 Data Sheet, p.31
    u16 val
    if     addr < \x0800 then val := Mem.registers.read16(addr)
    elseif addr < \x0c00 then val := Mem.windowedEeprom.read16((EPAGE cat addr{9..0}) | \x100000)
    elseif addr < \x1000 then val := Mem.nonWindowedEeprom.read16(addr)
    elseif addr < \x2000 then val := Mem.windowedRAM.read16(RPAGE cat addr{11..0})
    elseif addr < \x4000 then val := Mem.nonWindowedRAM.read16(addr)
    elseif addr < \x8000 then val := Mem.firstUnpagedflash.read16(addr)
    elseif addr < \xC000 then val := Mem.windowedFlash.read16((PPAGE{7..0} cat addr{13..0}) | \x400000)
    elseif addr < \xFFFF then val := Mem.secondUnpagedflash.read16(addr)
    end if
    return val
  }

  void memWrite8(u16 addr, u8 val)
  {
    -- description from MC9S12XDP512 Data Sheet, p.31
    if     addr < \x0800 then Mem.registers.write8(addr, val)
    elseif addr < \x2000 then Mem.windowedRAM.write8(RPAGE cat addr{11..0}, val)
    elseif addr < \x4000 then Mem.nonWindowedRAM.write8(addr, val)
    end if
  }

  void memWrite16(u16 addr, u16 val)
  {
    -- description from MC9S12XDP512 Data Sheet, p.31
    if     addr < \x0800 then Mem.registers.write16(addr, val)
    elseif addr < \x2000 then Mem.windowedRAM.write16(RPAGE cat addr{11..0}, val)
    elseif addr < \x4000 then Mem.nonWindowedRAM.write16(addr, val)
    end if
  }
}

component Fetcher {
  program counter u16 PC
  
  u16 val
  u1  fetchNeeded

-- does not work yet.

--  u8 fetchCode() { 
--    u8 result
--    if fetchNeeded then 
--      val := Mem.ram.read16(PC)
--      result := val{15..8}
--      fetchNeeded := false
--    else
--      result := val{7..0}
--      fetchNeeded := true
--    end if
--    PC := (u16)(PC+1)
--    return val
--  }

  u8 fetchCode() { 
    u8 result := Mem.memRead8(PC)
    PC := (u16)(PC+1)
    return result
  }

  u8 fetchMem(u16 addr) { 
    return Mem.memRead8(addr)
  }


}

component Reg {
  memory regs {
    width := 16 -- get 16 bits / access
    address := 0..20
    stride := 1
    type := register

    register u16 D maps to 0
    register u16 X maps to 2
    register u16 Y maps to 4
    register u16 SP maps to 6
    register u8 A maps to 0
    register u8 B maps to 1
    --register u8 PPAGE maps to 12
    register TMP3 maps to 10
    register TMP2 maps to 8
  }
}

component alu {

  register u8 CCR {
    C := slice{0} -- carry flag
    V := slice{1} -- overflow flag
    Z := slice{2} -- zero flag
    N := slice{3} -- neg flag
    I := slice{4} -- maskable interrupt control bit
    H := slice{5} -- half carry status bit
    X := slice{6} -- non-maskable interrupt control bit
    S := slice{7} -- STOP instruction control bit
  }

  void set_NZVC(u4 nzvc) {
    CCR{3..0} := nzvc 
  }

  void set_NZV(u3 nzv) {
    CCR{3..1} := nzv 
  }

  void set_ZVC(u3 zvc) {
    CCR{2..0} := zvc 
  }


  u8 neg_8(u8 op) {
    u8 res
    res := 0 - op
    CCR.N := res{7}
    CCR.Z := 0
    CCR.V := op = \x80
    CCR.C := op != 0
    return res
  }

  u8 com_8(u8 op) {
    u8 res
    res := ~op
    CCR.N := res{7}
    CCR.Z := 0
    CCR.V := 0
    CCR.C := 1
    return res
  }

  u8 sl_8(u8 op) {
    u8 res
    CCR.C:res := op << 1
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := res{7}^op{7}
    return res
  }

  u16 sl_16(u16 op) {
    u16 res
    res := op << 1
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := res{15}^op{15}
    CCR.C := op{15}
    return res
  }

  u8 asr_8(u8 op) {
    u8 res
    res := (u8)((s8)(op) >> 1)
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := res{7} ^ op{0}
    CCR.C := op{0}
    return res
  }

  u16 asr_16(u16 op) {
    u16 res
    res := (u16)((s16)(op) >> 1)
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := res{15} ^ op{0}
    CCR.C := op{0}
    return res
  }

  u8 lsr_8(u8 op) {
    u8 res
    res := op >> 1
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := res{7} ^ op{0}
    CCR.C := op{0}
    return res
  }

  u16 lsr_16(u16 op) {
    u16 res
    res := op >> 1
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := res{15} ^ op{0}
    CCR.C := op{0}
    return res
  }

  u8 rol_8(u8 op) {
    u8 res
    res := op << 1
    res{0} := CCR.C
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := res{7} ^ op{7}
    CCR.C := op{7}
    return res
  }

  u8 ror_8(u8 op) {
    u8 res
    res := op >> 1
    res{7} := CCR.C
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := res{7} ^ op{0}
    CCR.C := op{0}
    return res
  }

  u8 add_8(u8 a, u8 b) {
    u8 res
    res := (u8)(a + b)
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    return res
  }

  u16 add_16(u16 a, u16 b) {
    u17 res
    res := a + b
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := ~(a{15} ^ b{15}) & (a{15} ^ res{15})
    CCR.C := res{16}
    return res{16..0}
  }

  u16 add_16_noC(u16 a, u16 b) {
    u17 res
    res := a + b
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := ~(a{15} ^ b{15}) & (a{15} ^ res{15})
    return res{16..0}
  }

  u8 cmp_8(u8 a, u8 b) {
    u9 res
    res := a - b
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := a{7} & ~b{7} & ~res{7} | ~a{7} & b{7} & res{7}
    CCR.C := res{8}
    return res{7..0}
  }

  u16 cmp_16(u16 a, u16 b) {
    u17 res
    res := a - b
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := a{15} & ~b{15} & ~res{15} | ~a{15} & b{15} & res{15}
    CCR.C := res{16}
    return res{15..0}
  }

  u8 add_8_half(u8 a, u8 b) {
    u9 res
    res := a + b
--    alu.set_NZVC(res{7} cat res = 0 cat ~(a{7} ^ b{7}) & (a{7} ^ res{7}) cat a{7} & b{7} | a{7} & ~res{7} | b{7} & ~res{7} )
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    CCR.C := res{8}

    CCR.H := a{3} & b{3} | a{3} & ~res{3} | b{3} & ~res{3}
    return res{7..0}
  }

  --
  -- A REVOIR. Les calculs de flags sont ceux du databook qui sont apparament faux
  --
  u8 addc_8_half(u8 a, u8 b) {
    u9 res
    res := (u9)(a + b + CCR.C)
    -- alu.set_NZVC(res{7} cat res = 0 cat ~(a{7} ^ b{7}) & (a{7} ^ res{7}) cat a{7} & b{7} | a{7} & ~res{7} | b{7} & ~res{7} )
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    CCR.C := res{8}

    CCR.H := a{3} & b{3} | a{3} & ~res{3} | b{3} & ~res{3}
    return res{7..0}
  }

  u8 subc_8(u8 a, u8 b) {
    u9 res
    res := a - b - CCR.C
    -- alu.set_NZVC(res{7} cat res = 0 cat ~(a{7} ^ b{7}) & (a{7} ^ res{7}) cat a{7} & b{7} | a{7} & ~res{7} | b{7} & ~res{7} )
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    CCR.C := res{8}

    return res{7..0}
  }

  u16 sub_16(u16 a, u16 b) {
    u17 res
    res := a - b
    -- alu.set_NZVC(res{15} cat res = 0 cat ~(a{15} ^ b{15}) & (a{15} ^ res{15}) cat a{15} & b{15} | a{15} & ~res{15} | b{15} & ~res{15})
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := ~(a{15} ^ b{15}) & (a{15} ^ res{15})
    CCR.C := res{16}
    return res{15..0}
  }

  u8 and_8(u8 a, u8 b) {
    u8 res
    res := a & b
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := 0
    return res
  }

  u8 eor_8(u8 a, u8 b) {
    u8 res
    res := a ^ b
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := 0
    return res
  }

  u8 or_8(u8 a, u8 b) {
    u8 res
    res := a | b
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := 0
    return res
  }

  void tst_8(u8 op) {
    CCR.N := op{7}
    CCR.Z := op = 0
    CCR.V := 0
    CCR.C := 0
  }

  u8 clr_8() {
    CCR.N := 0
    CCR.Z := 1
    CCR.V := 0
    CCR.C := 0
    return 0
  }

  u16 clr_16() {
    CCR.N := 0
    CCR.Z := 1
    CCR.V := 0
    CCR.C := 0
    return 0
  }

  u32 div_32_16(u32 dd, u16 dv) {
    u32 qt
    u32 rm
    if dv != 0 then
      qt := dd / dv
      rm := dd % dv
      CCR.N := qt{15}
      CCR.Z := qt = 0
      CCR.V := qt > \xffff
      CCR.C := 0
    else
      qt := dd{15..0}
      rm := dv
      CCR.C := 1
    end if
    return qt{15..0} cat rm{15..0}
  }

  u32 divs_32_16(u32 dd, u16 dv) {
    s32 qt
    s32 rm
    if dv != 0 then
      qt := (s32)(dd) / (s16)(dv)
      rm := (s32)(dd) % (s16)(dv)
      CCR.N := qt{15}
      CCR.Z := qt = 0s
      CCR.V := qt > 32767s | qt < 0s-32768s
      CCR.C := 0
    else
      qt := (s32)(dd{15..0})
      rm := (s32)(dv)
      CCR.C := 1
    end if
    return qt{15..0} cat rm{15..0}
  }

  u32 fdiv_16_16(u16 dd, u16 dv) {
    u32 _add
    u32 qt
    u32 rm
    if dv != 0 & dd < dv then
      _add := dd << 16
      qt := _add / dv
      rm := _add % dv
      CCR.Z := qt = 0
      CCR.V := 0
      CCR.C := 0
    else
      qt := \xffff
      CCR.Z := 0
      CCR.V := dd < dv
      CCR.C := dv = 0
    end if
    return qt{15..0} cat rm{15..0}
  }

  u32 div_16_16(u16 dd, u16 dv) {
    u16 qt
    u16 rm
    if dv != 0 then
      qt := dd / dv
      rm := dd % dv
      CCR.Z := qt = 0
      CCR.V := 0
      CCR.C := 0
    else
      qt := dd
      rm := dv
      CCR.Z := 0
      CCR.V := 0
      CCR.C := 1
    end if
    return qt cat rm
  }

  u32 divs_16_16(u16 dd, u16 dv) {
    u16 qt
    u16 rm
    if dv != 0 then
      qt := (u16)((s16)(dd) / (s16)(dv))
      rm := dd % dv
      CCR.Z := qt = 0
      CCR.V := 0
      CCR.C := 0
    else
      qt := dd
      rm := dv
      CCR.Z := 0
      CCR.V := 0
      CCR.C := 1
    end if
    return qt cat rm
  }

  u32 emacs(u16 mop1, u16 mop2, u16 aop) {
    s32 res_mul
    s32 res
    s32 op
    op := (s32)(aop)
    res_mul := (s32)((s32)(mop1) * (s32)(mop2))
    res := (s32)(res_mul + op)
    CCR.N := res{31}
    CCR.Z := res = 0s
    CCR.V := ~(res_mul{31} ^ op{31}) & (res_mul{31} ^ res{31})
    CCR.C := res_mul{31} & op{31} | res_mul{31} & ~res{31} | op{31} & ~res{31}
    return (u32)(res)
  }

  u8 max8(u8 a, u8 b) {
    u8 res
    if a > b then
      res := a
    else
      res := b
    end if
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    CCR.C := a{7} & b{7} | a{7} & ~res{7} | b{7} & ~res{7}
    return res
  }

  u8 min8(u8 a, u8 b) {
    u8 res
    if a > b then
      res := b
    else
      res := a
    end if
    CCR.N := res{7}
    CCR.Z := res = 0
    CCR.V := ~(a{7} ^ b{7}) & (a{7} ^ res{7})
    CCR.C := a{7} & b{7} | a{7} & ~res{7} | b{7} & ~res{7}
    return res
  }

  u16 max16(u16 a, u16 b) {
    u16 res
    if a > b then
      res := a
    else
      res := b
    end if
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := ~(a{15} ^ b{15}) & (a{15} ^ res{15})
    CCR.C := a{15} & b{15} | a{15} & ~res{15} | b{15} & ~res{15}
    return res
  }

  u16 min16(u16 a, u16 b) {
    u16 res
    if a > b then
      res := b
    else
      res := a
    end if
    CCR.N := res{15}
    CCR.Z := res = 0
    CCR.V := ~(a{15} ^ b{15}) & (a{15} ^ res{15})
    CCR.C := a{15} & b{15} | a{15} & ~res{15} | b{15} & ~res{15}
    return res
  }

  u32 mul_16_16(u16 a, u16 b) {
    u32 res
    res := a * b
    CCR.N := res{31}
    CCR.Z := res = 0
    CCR.C := res{15}
    return res
  }

  u32 muls_16_16(u16 a, u16 b) {
    u32 res
    res := (u32)((s32)(a) * (s32)(b))
    CCR.N := res{31}
    CCR.Z := res = 0
    CCR.C := res{15}
    return res
  }

  u16 mul_8_8(u8 a, u8 b) {
    u18 res
    res := a * b
    return res
  }

  u16 etbl(u16 a, u8 b, u16 c) {
    u16 res
    res := (u16)(a + b * (c - a))
    CCR.N := res{15}
    CCR.Z := res = 0
    return res
  }
  u8 tbl(u8 a, u8 b, u8 c) {
    u8 res
    res := (u8)(a + b * (c - a))
    CCR.N := res{7}
    CCR.Z := res = 0
    return res
  }
}
format Instruction 
  select slice {7..0}
    case 0    is #BGND
    case \x59 is #ASLD

    case \x09 or \x03 is #DE16 de_reg16

    case \x11 is #EDIV 
    case \x13 is #EMUL 

    case \x08 or \x02 is #IN16 de_reg16 

    case \x49 is #LSRD 
    case \x01 is #MEM  
    case \x12 is #MUL  
             
    case \xA7 is #NOP  
             
    case \x0A is #RTC  
    case \x0B is #RTI  
    case \x3D is #RTS  
             
    case \x3F is #SWI  
             
    case \x3E is #WAI  
    case \x3C is #WAVR 

    case \x10 is #ANDCC imm8_am
             
    case \x18 is #inst18 inst_18 

    case \x1B or \x1A or \x19 is #LEA lea_reg16 LEA_am

    case \m1---1001 is #ADC reg8 adressing8_mode
    case \m1---1011 is #ADD reg8 adressing8_mode
    case \m11--0011 is #ADDD adressing16_mode
    case \m1---0100 is #AND reg8 adressing8_mode
                   
    case \m01--1000 is #ASL ext_xb_inh_am_1
                   
                   
    case \m01--0111 is #ASR ext_xb_inh_am_1
                   
    case \m0-0-11-- is Bop_or_STdir_inst
    case \m1---0101 is #BIT reg8 adressing8_mode
                   
    case \b00000111 is #BSR imm8_am
    case \m0010---- is #BRANCH branch_kind imm8_am
                   
    case \m0100101- is CALL_inst  -- 4Ah or 4Bh

    case \m011-1001 or \x87 or \xC7 is #CLR ext_xb_inh_am_2
                                   
    case \m10--0001 or \m11--0001   is #CMP reg8 adressing8_mode
                                   
    case \m011-0001 or \x41 or \x51 is #COM ext_xb_inh_am_1

    case \m10--11-- is #CP16 reg16 adressing16_mode
                   
    case \b00000100 is DITBranch_inst  -- 04h

    case \m011-0011 or \x43 or \x53 is #DEC ext_xb_inh_am_1

    case \m1---1000 is #EOR reg8 adressing8_mode 
    case \m011-0010 or \x42 or \x52 is #INC ext_xb_inh_am_1

    case \b00000110 or \b00000101 is JMP_inst  -- 05h or 06h

    case \b00010101 or \m0001011- is JSR_inst  -- 15h or 16h or 17h

    case \m1---0110 is #LDA reg8 adressing8_mode    -- 86h to F6h
    case \m11--11-- is #LD16 reg16 adressing16_mode -- CCh to FCh
                   
    case \m011-0100 is #LSR ext_xb_inh_am_1 -- 64h or 74h
    case \m011-0000 is #NEG ext_xb_inh_am_1 -- 60h or 70h
                   
    case \m1---1010 is #ORA reg8 adressing8_mode -- 8Ah to FAh
                   
    case \x14 is #ORCC imm8_am    -- 14h


    case \m011-0101 or \x45 or \x55 is #ROL ext_xb_inh_am_1 
    case \m011-0110 or \x46 or \x56 is #ROR ext_xb_inh_am_1 

    case \m1---0010 is #SBC  reg8 adressing8_mode   -- 82h to F2h
    case \m01--101- is #STA  reg8sta dir_ext_or_xb_am 
    case \m01--11-- is #ST16 reg16 dir_ext_or_xb_am

    case \m1---0000 is #SUB  reg8 adressing8_mode   -- 80h to F0h
    case \m10--0011 is #SUBD adressing16_mode       -- 83h to B3h
                   
    case \b10110111 is TFR_or_EXG_inst   -- B7h
                   
    case \m1---0111 is #TST ext_xb_inh_am_3 -- E7h or F7h
  end select
end format

format pushPull
  select slice {7..0}
    case \m0011011- or \b00111001 is #PSH8   -- 36h or 37h or 39h
      select slice {3..0}
        case 6 is #A 
        case 7 is #B 
        case 9 is #C 
      end select
    case \m0011001- or \b00111000 is #PUL8   -- 32h or 33h or 38h
      select slice {3..0}
        case 2 is #A 
        case 3 is #B 
        case 8 is #C 
      end select
                                 
    case \b00111011 or \m0011010- is #PSH16   -- 3Bh or 34h or 35h
      select slice {3..0}
        case \xB is #D 
        case 4   is #X 
        case 5   is #Y 
      end select
    case \b00111010 or \m0011000- is #PUL16   -- 3Ah or 30h or 31h
      select slice {3..0}
        case \xA is #D 
        case 0   is #X 
        case 1   is #Y 
      end select
  end select
end format

format CALL_inst #CALL 
  select slice {0}
    case 0 is #CALL_IMM imm16_am imm8_am
    case 1 is #CALL_XB xb_am imm8_am
  end select
end format

format inst_18 
  select slice +{7..0}
    case \m00010111 is #CBA       -- 17h
    case \m00010100 is #EDIVS     -- 14h

    case \m00010010 is #EMACS ext_am -- 12h
    case \m00011010 is #EMAXD xb_am  -- 1Ah
    case \m00011110 is #EMAXM xb_am  -- 1Eh
    case \m00011011 is #EMIND xb_am  -- 1Bh
    case \m00011111 is #EMINM xb_am  -- 1Fh
                   
    case \m00010011 is #EMULS     -- 13h
    case \m00010001 is #FDIV      -- 11h
    case \m00010000 is #IDIV      -- 10h
    case \m00010101 is #IDIVS     -- 15h
                   
    case \m0010---- is #LG_BRANCH branch_kind imm16_am  -- 2xh
    case \m00011000 is #MAXA xb_am  -- 18h
    case \m00011100 is #MAXM xb_am  -- 1Ch
    case \m00011001 is #MINA xb_am  -- 19h
    case \m00011101 is #MINM xb_am  -- 1Dh

    case \m00001--- is MOVB_TAB_TBA_inst  -- 08xh
    case \m00000--- is MOVW_ABA_DAA_inst  -- 00xh

    case \m01--0111 is inst_ASR16 

    case \m0011---- is inst_183x  -- 3xh

    case \m011-1001 or \x87 or \xC7 is #CLRW ext_xb_inh_am_2w   -- only HCS12X
    case \x62 or \x72 or \x42 or \x52 is #INCW ext_xb_inh_am_2w -- only HCS12X

  end select
end format

format inst_ASR16 #ASR16
  select slice {5..4}
    case \m0- is inh_am_1w
    case \m10 is ext_am
    case \m11 is xb_am
  end select
end format

format inst_183x 
  select slice {3..0}
    case \xA is #REV     
    case \xB is #REVW  
    case \xC is #WAV   
    case \xD is TBL_inst
    case \xE is #STOP
    case \xF is ETBL_inst
    others   is #TRAP trap_num := slice{7..0} -- 0 to 9 
  end select
end format

format ETBL_inst slice +{7..0} #ETBL 
  Indexed_5bits_offset
end format

format MOVB_TAB_TBA_inst
  select slice {2..0}
    case \m110 is #TAB
    case \m111 is #TBA
    others     is MOVB_inst
  end select
end format

format MOVB_inst #MOVB
  select slice {3..0}
    case \xB is imm8_am ext_am
    case \x8 is xb_am   imm8_am
    case \xC is ext_ext 
    case \x9 is ext_idx 
    case \xD is idx_ext 
    case \xA is idx_idx 
  end select
end format

format MOVW_inst #MOVW
  select slice {3..0}
    case 3 is imm16_am ext_am
    case 0 is xb_am imm16_am
    case 4 is ext_ext   
    case 1 is ext_idx   
    case 5 is idx_ext   
    case 2 is idx_idx   
  end select
end format

format ext_ext  ext_am@SRC   ext_am@DST end format
format ext_idx  xb_am@SRC    ext_am@DST end format 
format idx_ext  xb_am@DST    ext_am@SRC end format 
format idx_idx  xb_am@SRC    xb_am@DST  end format

format MOVW_ABA_DAA_inst
  select slice {2..0}
    case \m110 is #ABA 
    case \m111 is #DAA 
    others     is MOVW_inst 
  end select
end format

format TBL_inst slice +{7..0} #TBL Indexed_5bits_offset end format

format LEA_am
  select slice +{7..0}
    case \m--0----- is Indexed_5bits_offset   -- rr0nnnnn
    case \m111--00- is Indexed_9bits_offset   -- 111rr00s
    case \m111--010 is Indexed_16bits_offset  -- 111rr00s
    case \m111--1-- is Accumulator_offset     -- 111rr1aa
  end select
end format

format DITBranch_inst slice +{7..0} #DITBr 
  DIT DITB_cond DIT_reg DIT_offset 
end format

format DIT_offset slice {7..0}+{7..0}
  offset := signed slice{4}{7..0}
end format

format DIT_reg 
  select slice {2..0}
    case 0 is #A 
    case 1 is #B 
    case 4 is #D 
    case 5 is #X 
    case 6 is #Y 
    case 7 is #S 
  end select
end format

format DIT 
  select slice {7..6}
    case 0 is #DB 
    case 1 is #TB 
    case 2 is #IB 
  end select
end format

format DITB_cond 
  select slice {5}
     case 0 is #EQ 
     case 1 is #NE 
  end select
end format

format JMP_inst  #JMP 
  select slice{3..0}
       case \x6 is ext_am 
       case \x5 is xb_am  
  end select
end format

format JSR_inst #JSR 
  select slice{3..0}
       case \x7 is dir_am 
       case \x6 is ext_am 
       case \x5 is xb_am  
  end select
end format

format TFR_or_EXG_inst 
  select slice +{7} 
      case 0 is #TFR ET_SRC_reg@src ET_DST_reg@dst
      case 1 is #EXG ET_SRC_reg@src ET_DST_reg@dst
  end select
end format

format ET_SRC_reg 
  select slice {6..4}
    case 0 is #A     
    case 1 is #B     
    case 2 is #C     
    case 3 is #TMP3  
    case 4 is #D     
    case 5 is #X     
    case 6 is #Y     
    case 7 is #S     
  end select
end format

format ET_DST_reg 
  select slice {2..0}
    case 0 is #A    
    case 1 is #B    
    case 2 is #C    
    case 3 is #TMP2 
    case 4 is #D    
    case 5 is #X    
    case 6 is #Y    
    case 7 is #S    
  end select
end format

--------------------------------------------------------------------------------
-- branches
--------------------------------------------------------------------------------

format branch_kind 
  select slice {3..0}
    case 4   is #CC 
    case 5   is #CS 
    case 7   is #EQ 
    case \xC is #GE 
    case \xE is #GT 
    case 2   is #HI 
    case \xF is #LE 
    case 3   is #LS 
    case \xD is #LT 
    case \xB is #MI 
    case 6   is #NE 
    case \xA is #PL 
    case 0   is #RA 
    case 1   is #RN 
    case 8   is #VC 
    case 9   is #VS 
  end select
end format

--------------------------------------------------------------------------------
-- addressing modes
--------------------------------------------------------------------------------
format adressing8_mode 
  select slice {7, 5..4}
    case \m1_00 is imm8_am 
    case \m1_01 is dir_am  
    case \m1_11 is ext_am  
    case \m1_10 is xb_am   
  end select
end format

format adressing16_mode 
  select slice {7, 5..4}
    case \m1_00 is imm16_am
    case \m1_01 is dir_am  
    case \m1_11 is ext_am  
    case \m1_10 is xb_am   
  end select
end format

format ext_xb_inh_am_1 
  select slice {7..4}
     case \m0111 is ext_am   
     case \m0110 is xb_am    
     case \m010- is inh_am_1  
  end select
end format

format ext_xb_inh_am_2 
  select slice {7..4}
    case \m0111 is ext_am  
    case \m0110 is xb_am   
    case \m1-00 is inh_am_2 
  end select
end format

format ext_xb_inh_am_2w --words (use X and Y instead of A and B)
  select slice {7..4}
    case \m0111 is ext_am  
    case \m0110 is xb_am   
    case \m1-00 is inh_am_2w
  end select
end format

format ext_xb_inh_am_3 
  select slice {6..4}
    case \m111 is ext_am  
    case \m110 is xb_am   
    case \m-01 is inh_am_2 
  end select
end format

format dir_ext_or_xb_am 
  select slice {7..4}
    case \x5 is dir_am 
    case \x7 is ext_am 
    case \x6 is xb_am  
  end select
end format

--------------------------------------------------------------------------------
-- inherent addressing modes
--------------------------------------------------------------------------------
format inh_am_1 #INH_AM 
  select slice{4}
    case 0 is #A 
    case 1 is #B 
  end select
end format

format inh_am_1w #INH_AMW
  select slice{4}
    case 0 is #X 
    case 1 is #Y 
  end select
end format

format inh_am_2 #INH_AM 
  select slice{6}
    case 0 is #A 
    case 1 is #B 
  end select
end format

format inh_am_2w #INH_AMW
  select slice{6}
    case 0 is #X 
    case 1 is #Y 
  end select
end format

--------------------------------------------------------------------------------
-- Immediate addressing modes
--------------------------------------------------------------------------------
format imm8_am slice +{7..0} #IMM8 
  imm8_value := signed slice{7..0}
end format

format imm16_am slice +{7..0}{7..0} #IMM16 
  imm16_value := signed slice{7..0}{7..0}
end format

--------------------------------------------------------------------------------
-- Direct addressing modes
--------------------------------------------------------------------------------
format dir_am slice +{7..0} #DIR_ADDR 
  addr8 := slice{7..0}
end format

--------------------------------------------------------------------------------
-- Extended addressing modes
--------------------------------------------------------------------------------
format ext_am slice +{7..0}{7..0} #EXT_ADDR 
  addr16 := slice{7..0}{7..0}
end format

--------------------------------------------------------------------------------
-- Indexed addressing modes
--------------------------------------------------------------------------------
format xb_am 
  select slice +{7..0}
    case \m--0----- is Indexed_5bits_offset    -- rr0nnnnn
    case \m111--00- is Indexed_9bits_offset    -- 111rr00s
    case \m111--010 is Indexed_16bits_offset   -- 111rr00s
    case \m111--011 is Indexed_16bits_indirect -- 111rr011
    case \m111--1-- is Indexed_acc_offset      -- 111rr1aa
    case \m001----- or 
         \m011----- or 
         \m101----- is Auto_incremented         -- rr1pnnnn
  end select
end format

format reg_index_1 
  select slice {7,6}
    case 0 is #Xi 
    case 1 is #Yi 
    case 2 is #Si 
    case 3 is #PCi
  end select
end format

format reg_index_2 
  select slice {4,3}
    case 0 is #Xi  
    case 1 is #Yi  
    case 2 is #Si  
    case 3 is #PCi 
  end select
end format

format reg_offset 
  select slice {1,0}
    case 0 is #Aoff
    case 1 is #Boff
    case 2 is #Doff
  end select
end format

format xb_9_offset  slice {7..0}+{7..0} offset := signed slice{0}{7..0} end format
format xb_16_offset slice +{7..0}{7..0} offset := signed slice{7..0}{7..0} end format

format Indexed_5bits_offset #IDX_5B_OFF
  reg_index_1
  offset    := signed slice{4..0}
end format

format Indexed_9bits_offset  #IDX_9B_OFF
  reg_index_2
  xb_9_offset
end format

format Indexed_16bits_offset  #IDX_16B_OFF 
  reg_index_2
  xb_16_offset
end format

format Indexed_16bits_indirect #IND_IDX_16B 
  reg_index_2
  xb_16_offset
end format

format Indexed_acc_offset 
  select slice {7..0} 
    case \m111--111 is Accumulator_D_offset_indexed_indirect
    others          is Accumulator_offset                   
  end select
end format

format Auto_incremented #AUTO_INC
  reg_index_1
  increment := signed slice{3..0}
  pre_post  := slice{4}
end format

format Accumulator_D_offset_indexed_indirect #IDX_ACC_D_OFF 
  reg_index_2
end format

format Accumulator_offset #IDX_ACC_OFF 
  reg_index_2
  reg_offset
end format

--------------------------------------------------------------------------------
-- BCLR and BSET instructions and addressing modes
--------------------------------------------------------------------------------
format B_am 
  select slice {7..4} 
    case \x4 is dir_am
    case \x1 is ext_am
    case \x0 is xb_am 
  end select
end format

format Bop_or_STdir_inst 
  select slice {3..0} 
    case \xD is #BCLR B_am imm8_am
    case \xF is #BRCLR B_am imm8_am@mask imm8_am@rel
    case \xE is #BRSET B_am imm8_am@mask imm8_am@rel
    case \xC is #BSET B_am imm8_am
  end select
end format

--------------------------------------------------------------------------------
-- BIT8 instructions (BITA and BITB)
--------------------------------------------------------------------------------
format reg8sta
  select slice{0}
    case 0 is #A
    case 1 is #B
  end select
end format

format reg8 
  select slice{6}
    case 0 is #A
    case 1 is #B
  end select
end format

format reg16 
  select slice{1..0} 
    case 0 is #D
    case 3 is #S
    case 2 is #X
    case 1 is #Y
  end select
end format

format de_reg16 
  select slice {3}
    case 1 is #X
    case 0 is #Y
  end select
end format

format lea_reg16 
  select slice {1..0}
    case 2 is #X
    case 1 is #Y
    case 3 is #S
  end select
end format
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Syntax description
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

syntax reg8 
  select
    case #A "A"
    case #B "B"
  end select
end syntax

syntax reg16 
  select
    case #D "D"
    case #Y "Y"
    case #X "X"
    case #S "S"
  end select
end syntax

syntax de_reg16 
  select
    case #Y "Y"
    case #X "X"
  end select
end syntax

syntax lea_reg16 
  select
    case #Y "Y"
    case #X "X"
    case #S "S"
  end select
end syntax

syntax regind 
  select
    case #Xi  "X"
    case #Yi  "Y"
    case #Si  "SP"
    case #PCi "PC"
  end select
end syntax

syntax regoff 
  select
    case #Aoff "A"
    case #Boff "B"
    case #Doff "D"
  end select
end syntax


syntax imm8    #IMM8         field s8 imm8_value   " #\x",imm8_value end syntax
syntax diraddr #IMM8         field s8 imm8_value   " \x",imm8_value end syntax
syntax imm16   #IMM16        field s16 imm16_value " #\x",imm16_value end syntax
syntax rel16   #IMM16        field s16 imm16_value " \d",imm16_value end syntax
syntax dir   #DIR_ADDR       field u8 addr8        " \x",addr8 end syntax
syntax ext   #EXT_ADDR       field u16 addr16      " \x",addr16 end syntax
syntax x5    #IDX_5B_OFF     field s5 offset       " \x,",offset regind end syntax
syntax x9    #IDX_9B_OFF     field s9 offset       " \x,",offset regind end syntax
syntax x16   #IDX_16B_OFF    field s16 offset      " \x,",offset regind end syntax
syntax xi16  #IND_IDX_16B    field s16 offset      " [\d,",offset regind end syntax
syntax xaccD #IDX_ACC_D_OFF  " [D," regind "]" end syntax
syntax xao   #IDX_ACC_OFF    " " regoff "," regind end syntax
syntax auto  #AUTO_INC      
  field s4 increment
  field u1 pre_post
  if increment >= (s4)(0) then 
    " \d,",increment + (s4)(1)
  else
    " \d,",(s4)(0) - increment
  end if 
  if increment >= (s4)(0) && pre_post = 0 then "+" end if 
  if increment < (s4)(0) && pre_post = 0 then "-" end if 
  regind
  if increment >= (s4)(0) && pre_post = 1 then "+" end if 
  if increment < (s4)(0) && pre_post = 1 then "-" end if 
end syntax
syntax inhw #INH_AMW
  de_reg16
end syntax
syntax inh #INH_AM 
  reg8
end syntax
syntax xb 
  select
    case x5 
    case x9 
    case x16 
    case xi16 
    case xaccD 
    case xao 
    case auto 
  end select
end syntax
syntax inds 
  select
    case x5 
    case x9 
    case x16 
    case xao
  end select 
end syntax
syntax byte_am 
  select
    case imm8 
    case dir 
    case ext 
    case xb 
  end select
end syntax
syntax word_am 
  select
    case imm16 
    case dir 
    case ext 
    case xb
  end select 
end syntax
syntax ext_xb_inhw
  select
    case "W" ext 
    case "W" xb 
    case inhw 
  end select
end syntax
syntax ext_xb_inh 
  select
    case ext 
    case xb 
    case inh 
  end select
end syntax
syntax dir_ext_xb 
  select
    case dir 
    case ext 
    case xb
  end select 
end syntax
syntax ext_xb 
  select
    case ext 
    case xb
  end select 
end syntax

syntax branch_kind 
  select
    case #CC "CC"
    case #CS "CS"
    case #EQ "EQ"
    case #GE "GE"
    case #GT "GT"
    case #HI "HI"
    case #LE "LE"
    case #LS "LS"
    case #LT "LT"
    case #MI "MI"
    case #NE "NE"
    case #PL "PL"
    case #RA "RA"
    case #RN "RN"
    case #VC "VC"
    case #VS "VS"
  end select
end syntax



syntax ABA #ABA #inst18 "ABA" end syntax
syntax ADC #ADC      "ADC" reg8 byte_am end syntax
syntax ADD #ADD      "ADD" reg8 byte_am end syntax
syntax ADDD #ADDD    "ADDD" word_am end syntax
syntax AND #AND      "AND" reg8 byte_am end syntax
syntax ANDCC #ANDCC  "ANDCC" imm8 end syntax
syntax ASL #ASL      "ASL" ext_xb_inh end syntax
syntax ASLD #ASLD    "ASLD" end syntax
syntax ASR #ASR      "ASR" ext_xb_inh end syntax
syntax ASR16 #ASR16 #inst18 "ASR" ext_xb_inhw end syntax
syntax Branch #BRANCH         "B" branch_kind imm8 end syntax
syntax LongBranch #LG_BRANCH #inst18 "LB" branch_kind imm16 end syntax
syntax BCLR #BCLR    "BCLR" dir_ext_xb diraddr end syntax
syntax BSET #BSET    "BSET" dir_ext_xb diraddr end syntax
syntax BGND #BGND    "BGND" end syntax
syntax BIT8 #BIT     "BIT" reg8 byte_am end syntax
syntax BRCLR #BRCLR  "BRCLR" dir_ext_xb diraddr@mask diraddr@rel end syntax
syntax BRSET #BRSET  "BRSET" dir_ext_xb diraddr@mask diraddr@rel end syntax
syntax BSR #BSR  "BSR" diraddr end syntax
syntax CALLd #CALL #CALL_IMM  "CALL" imm16 diraddr end syntax
syntax CALLi #CALL #CALL_XB  "CALL" xb diraddr end syntax
syntax CBA #CBA #inst18    "CBA" end syntax
syntax CLR #CLR    "CLR" ext_xb_inh end syntax
syntax CMP8 #CMP   "CMP" reg8 byte_am end syntax
syntax COM #COM    "COM" ext_xb_inh end syntax
syntax CP16 #CP16  "CP" reg16 word_am end syntax
syntax DAA #DAA #inst18 "DAA" end syntax

syntax BMnemo 
  select
    case #DB "DB"
    case #TB "TB"
    case #IB "IB"
  end select
end syntax

syntax BCond 
  select
    case #EQ "EQ"
    case #NE "NE"
  end select
end syntax

syntax DBReg 
  select
    case #A "A"
    case #B "B"
    case #D "D"
    case #X "X"
    case #Y "Y"
    case #S "SP"
  end select
end syntax
syntax DecBranch #DITBr  field s9 offset BMnemo BCond " " DBReg ",\d",offset end syntax
syntax DEC #DEC  "DEC" ext_xb_inh end syntax
syntax DE16 #DE16  "DE" de_reg16 end syntax
syntax EDIV #EDIV  "EDIV" end syntax
syntax EDIVS #EDIVS #inst18 "EDIVS" end syntax
syntax EMACS #EMACS #inst18 "EMACS" ext end syntax
syntax EMAXD #EMAXD #inst18 "EMAXD" xb end syntax
syntax EMAXM #EMAXM #inst18 "EMAXM" xb end syntax
syntax EMIND #EMIND #inst18 "EMIND" xb end syntax
syntax EMINM #EMINM #inst18 "EMINM" xb end syntax
syntax EMUL #EMUL  "EMUL" end syntax
syntax EMULS #EMULS #inst18 "EMULS" end syntax
syntax EOR #EOR  "EOR" reg8 byte_am end syntax
syntax ETBL #ETBL #inst18 "ETBL" x5 end syntax
syntax TBL #TBL #inst18 "TBL" x5 end syntax

syntax common_regs 
  select
    case #A "A"
    case #B "B"
    case #C "CCR"
    case #D "D"
    case #X "X"
    case #Y "Y"
    case #S "SP"
  end select
end syntax

syntax src_regs 
  select
    case common_regs
    case #TMP3 "TMP3"
  end select
end syntax

syntax dst_regs 
  select
    case common_regs
    case #TMP2 "TMP2"
  end select
end syntax

syntax EXG   #EXG   "EXG " src_regs@src "," dst_regs@dst end syntax
syntax TFR   #TFR   "TFR " src_regs@src "," dst_regs@dst end syntax
syntax FDIV  #FDIV  #inst18 "FDIV" end syntax
syntax IDIV  #IDIV  #inst18  "IDIV" end syntax
syntax IDIVS #IDIVS #inst18 "IDIVS" end syntax
syntax INC   #INC   "INC" ext_xb_inh end syntax
syntax INCW  #INCW #inst18 "INC" ext_xb_inhw end syntax
syntax CLRW  #CLRW #inst18 "CLR" ext_xb_inhw end syntax
syntax IN16  #IN16  "IN" de_reg16 end syntax
syntax JMP   #JMP   "JMP" ext_xb end syntax
syntax JSR   #JSR   "JSR" dir_ext_xb end syntax
syntax LDA   #LDA   "LDA" reg8 byte_am end syntax
syntax LD16  #LD16  "LD" reg16 word_am end syntax
syntax LEA   #LEA   "LEA" lea_reg16 inds end syntax
syntax LSR   #LSR   "LSR" ext_xb_inh end syntax
syntax LSRD  #LSRD  "LSRD" end syntax
syntax MAXA  #MAXA #inst18 "MAXA" xb end syntax
syntax MAXM  #MAXM #inst18 "MAXM" xb end syntax
syntax MEM   #MEM   "MEM" end syntax
syntax MINA  #MINA #inst18 "MINA" xb end syntax
syntax MINM  #MINM #inst18 "MINM" xb end syntax

syntax imm8_ext  imm8 ext end syntax
syntax imm8_idx  imm8 xb end syntax
syntax imm16_ext imm16 ext end syntax
syntax imm16_idx imm16 xb end syntax
syntax ext_ext ext@SRC ext@DST end syntax
syntax ext_idx ext@SRC xb@DST end syntax
syntax idx_ext xb@SRC ext@DST end syntax
syntax idx_idx xb@SRC xb@DST end syntax
syntax mov8_args
  select
    case imm8_ext 
    case imm8_idx 
    case ext_ext 
    case idx_idx 
    case ext_idx 
    case idx_ext 
  end select
end syntax
syntax mov16_args 
  select
    case imm16_ext 
    case imm16_idx 
    case ext_ext 
    case idx_idx 
    case ext_idx 
    case idx_ext 
  end select
end syntax
syntax MOVB #MOVB #inst18 "MOVB" mov8_args end syntax
syntax MOVW #MOVW #inst18 "MOVW" mov16_args end syntax
syntax MUL  #MUL  "MUL" end syntax
syntax NEG  #NEG  "NEG" ext_xb_inh end syntax
syntax NOP  #NOP  "NOP" end syntax
syntax ORA  #ORA  "ORA" reg8 byte_am end syntax
syntax ORCC #ORCC "ORCC" imm8 end syntax
syntax PSHA #PSH8 #A "PSHA" end syntax
syntax PSHB #PSH8 #B "PSHB" end syntax
syntax PSHC #PSH8 #C "PSHC" end syntax
syntax PSHD #PSH16 #D "PSHD" end syntax
syntax PSHX #PSH16 #X "PSHX" end syntax
syntax PSHY #PSH16 #Y "PSHY" end syntax
syntax PULA #PUL8 #A "PULA" end syntax
syntax PULB #PUL8 #B "PULB" end syntax
syntax PULC #PUL8 #C "PULC" end syntax
syntax PULD #PUL16 #D "PULD" end syntax
syntax PULX #PUL16 #X "PULX" end syntax
syntax PULY #PUL16 #Y "PULY" end syntax
syntax REV  #REV  #inst18 "REV" end syntax
syntax REVW #REVW #inst18 "REVW" end syntax
syntax ROL  #ROL  "ROL" ext_xb_inh end syntax
syntax ROR  #ROR  "ROR" ext_xb_inh end syntax
syntax RTC  #RTC  "RTC" end syntax
syntax RTI  #RTI  "RTI" end syntax
syntax RTS  #RTS  "RTS" end syntax
syntax SBA  #SBA  "SBA" end syntax
syntax SBC  #SBC  "SBC" reg8 byte_am end syntax
syntax STA  #STA  "STA" reg8 dir_ext_xb end syntax
syntax ST16 #ST16 "ST" reg16 dir_ext_xb end syntax
syntax STOP #STOP #inst18 "STOP" end syntax
syntax SUB  #SUB  "SUB" reg8 byte_am end syntax
syntax SUBD #SUBD "SUBD" word_am end syntax
syntax SWI  #SWI  "SWI" end syntax
syntax TAB  #TAB #inst18 "TAB" end syntax
syntax TBA  #TBA #inst18 "TBA" end syntax
syntax TRAP #TRAP #inst18 field u8 trap_num "TRAP \d",trap_num end syntax
syntax TST  #TST  "TST" ext_xb_inh end syntax
syntax WAI  #WAI  "WAI" end syntax
syntax WAV  #WAV #inst18 "WAV" end syntax
syntax WAVR #WAVR "WAVR" end syntax

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Behavior description
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
behavior imm8(out s8 imm) #IMM8 
   field s8 imm8_value
   do imm := imm8_value end do
end behavior

behavior imm16(out s16 imm) #IMM16 
   field s16 imm16_value
   do imm := imm16_value end do
end behavior

behavior dir_am(out u16 _add) #DIR_ADDR 
  field u16 addr8
  do _add := (u16)(addr8) end do
end behavior

behavior ext_am(out u16 _add) #EXT_ADDR 
  field u16 addr16
  do _add := addr16 end do
end behavior

behavior Indexed_5bits_offset(out u16 _add) #IDX_5B_OFF 
  u16 index
  regind(index)
  field s5 offset
  do _add := (u16)((s16)(index) + offset) end do
end behavior

behavior Indexed_9bits_offset(out u16 _add) #IDX_9B_OFF 
  u16 index
  regind(index)
  field s9 offset
  do _add := (u16)((s16)(index) + offset) end do
end behavior

behavior Indexed_16bits_offset(out u16 _add) #IDX_16B_OFF 
  u16 index
  regind(index)
  field s16 offset
  do _add := (u16)((s16)(index) + offset) end do
end behavior

-- ATTENTION semantique incorrecte. si le registre d'index est post
-- incremente et est le mme que le registre operande, la valeur
-- sera deja incrementee
behavior Auto_incremented(out u16 _add) #AUTO_INC 
  field s4 increment
  field u1 pre_post
  u16 index
  u16 indexed_add
  regind(index)
  do 
    s5 inc
    inc := increment
    if inc >= 0s then inc := (s5)(inc + 1s) end if
    indexed_add := (u16)((s16)(index) + inc)
    if pre_post = 0 then
      _add := indexed_add
    else 
      _add := index
    end if
  end do
  put_regind(indexed_add)
end behavior

behavior Indexed_16bits_indirect(out u16 _add) #IND_IDX_16B 
  u16 index
  regind(index)
  field s16 offset
  do 
    u16 ptr_add
    ptr_add := (u16)((s16)(index) + offset)
    _add := Mem.memRead16(ptr_add)
  end do
end behavior

behavior Indexed_acc_offset(out u16 _add) #IDX_ACC_OFF 
  u16 index
  u16 offset
  regind(index)
  regoff(offset)
  do 
    _add := (u16)(index + offset)
  end do
end behavior

behavior Indexed_acc_D_offset(out u16 _add) #IDX_ACC_D_OFF 
  u16 index
  regind(index)
  u16 ptr_add
  do 
    ptr_add := (u16)(index + D)
    _add := Mem.memRead16(ptr_add)
  end do
end behavior

behavior regoff(out u16 offset) 
  select
    case #Aoff do offset := (u16)(A) end do
    case #Boff do offset := (u16)(B) end do
    case #Doff do offset := D end do
  end select
end behavior

behavior regind(out u16 index) 
  select
    case #Xi  do index := X end do
    case #Yi  do index := Y end do
    case #Si  do index := SP end do
    case #PCi do index := PC end do
  end select
end behavior

behavior put_regind(u16 index) 
  select
    case #Xi  do X := index end do
    case #Yi  do Y := index end do
    case #Si  do SP := index end do
    case #PCi do PC := index end do
  end select
end behavior
behavior xb_am(out u16 _add) 
  select
    case Indexed_5bits_offset(_add)
    case Indexed_9bits_offset(_add)
    case Indexed_16bits_offset(_add)
    case Indexed_16bits_indirect(_add)
    case Indexed_acc_offset(_add)
    case Indexed_acc_D_offset(_add)
    case Auto_incremented(_add)
  end select
end behavior
     
behavior get_mono_operand_addr(out u16 _add) 
  select
    case ext_am(_add)
    case xb_am(_add)
  end select
end behavior

behavior dst_mono_operation8(out u8 res) #CLR  
  do res := alu.clr_8() end do
end behavior

behavior src_mono_operation8(u8 op) #TST  
  do alu.tst_8(op) end do
end behavior

behavior mono_operation8(u8 op, out u8 res) 
  select
    case #COM  do res := alu.com_8(op) end do
    case #ASL  do res := alu.sl_8(op) end do	-- same as LSL
    case #ASR  do res := alu.asr_8(op) end do
    case #DEC  do res := alu.add_8(op,0-1) end do
    case #INC  do res := alu.add_8(op,1) end do
    case #NEG  do res := alu.neg_8(op) end do
    case #ROL  do res := alu.rol_8(op) end do
    case #ROR  do res := alu.ror_8(op) end do
    case #LSR  do res := alu.lsr_8(op) end do
  end select
end behavior

behavior monadic8_reg_inst #INH_AM 
  u8 reg
  u8 res
  get_reg8(reg)
  mono_operation8(reg,res)
  put_reg8(res)
end behavior

behavior dst_monadic8_reg_inst #INH_AM 
  u8 res
  dst_mono_operation8(res)
  put_reg8(res)
end behavior

behavior src_monadic8_reg_inst #INH_AM 
  u8 reg
  get_reg8(reg)
  src_mono_operation8(reg)
end behavior

behavior monadic8_mem_inst 
  u16 _add
  u8 op
  u8 res
  get_mono_operand_addr(_add)
  do  op := Mem.memRead8(_add) end do
  mono_operation8(op,res)
  do Mem.memWrite8(_add,res) end do
end behavior

behavior dst_monadic8_mem_inst 
  u16 _add
  u8 res
  get_mono_operand_addr(_add)
  dst_mono_operation8(res)
  do Mem.memWrite8(_add,res) end do
end behavior

behavior src_monadic8_mem_inst 
  u16 _add
  u8 op
  get_mono_operand_addr(_add)
  do  op := Mem.memRead8(_add) end do
  src_mono_operation8(op)
end behavior

behavior get_dyadic_operand_addr(out u16 _add) 
  select
    case dir_am(_add)
    case ext_am(_add)
    case xb_am(_add)
  end select
end behavior

behavior get_reg8(out u8 reg) 
  select
    case #A do reg := A end do
    case #B do reg := B end do
  end select
end behavior

behavior put_reg8(u8 reg) 
  select
    case #A do A := reg end do
    case #B do B := reg end do
  end select
end behavior

behavior get_reg16(out u16 reg) 
  select
    case #D do reg := D end do
    case #S do reg := SP end do
    case #X do reg := X end do
    case #Y do reg := Y end do
  end select
end behavior

behavior put_reg16(u16 reg) 
  select
    case #D do D := reg end do
    case #S do SP := reg end do
    case #X do X := reg end do
    case #Y do Y := reg end do
  end select
end behavior

behavior dyadic_operation8(u8 a, u8 b, out u8 res) 
  select
    case #ADC do res := alu.addc_8_half(a,b) end do
    case #ADD do res := alu.add_8_half(a,b) end do
    case #AND do res := alu.and_8(a,b) end do
    case #EOR do res := alu.eor_8(a,b) end do
    case #ORA do res := alu.or_8(a,b) end do
    case #SBC do res := alu.subc_8(a,b) end do
    case #SUB do res := alu.cmp_8(a,b) end do
  end select
end behavior

behavior src_dyadic_operation8(u8 a, u8 b) 
  select
    case #BIT do u8 res res := alu.and_8(a,b) end do
    case #CMP do u8 res res := alu.cmp_8(a,b) end do
  end select
end behavior

behavior dyadic8_mem_inst 
  u16 _add
  u8 reg
  u8 op
  get_dyadic_operand_addr(_add)
  get_reg8(reg)
  do op := Mem.memRead8(_add)end do
  dyadic_operation8(reg,op,reg)
  put_reg8(reg)
end behavior

behavior src_dyadic8_mem_inst 
  u16 _add
  u8 reg
  u8 op
  get_dyadic_operand_addr(_add)
  get_reg8(reg)
  do op := Mem.memRead8(_add) end do
  src_dyadic_operation8(reg,op)
end behavior

behavior src_dyadic8_imm_inst 
  s8 imm
  u8 reg
  imm8(imm)
  get_reg8(reg)
  src_dyadic_operation8(reg,(u8)(imm))
end behavior

behavior src_dyadic_operation16(u16 op1, u16 op2) #CP16 
  do u16 res res := alu.cmp_16(op1,(u16)(op2)) end do
end behavior

behavior src_dyadic16_mem_inst
  u16 _add
  u16 reg
  u16 op
  get_dyadic_operand_addr(_add)
  get_reg16(reg)
  do op := Mem.memRead16(_add) end do
  src_dyadic_operation16(reg,op)
end behavior

behavior src_dyadic16_imm_inst 
  u16 reg
  s16 op
  imm16(op)
  get_reg16(reg)
  src_dyadic_operation16(reg,(u16)(op))
end behavior

behavior reg8_ref(out u8 reg) 
  select
    case #A do reg := A end do
    case #B do reg := B end do
  end select
end behavior

--behavior dyadic8_imm_inst {
--  s8 imm
--  register u8 reg {#A is A#B is B} 
--  imm8(imm)
----  reg8_ref(reg)
--  dyadic_operation8(reg,(u8)(imm),reg)
--}
 
behavior dyadic8_imm_inst 
  s8 imm
  u8 reg
  imm8(imm)
  get_reg8(reg)
  dyadic_operation8(reg,(u8)(imm),reg)
  put_reg8(reg)
end behavior

behavior dyadic_D_operation16(u16 b) 
  select
    case #ADDD do D := alu.add_16(D,b) end do
    case #SUBD do D := alu.sub_16(D,b) end do
  end select
end behavior

behavior dyadic16_mem_inst 
  u16 _add
  u16 op
  get_dyadic_operand_addr(_add)
  do op := Mem.memRead16(_add)end do
  dyadic_D_operation16(op)
end behavior

behavior dyadic16_imm_inst 
  s16 imm
  imm16(imm)
  dyadic_D_operation16((u16)(imm))
end behavior

-- See page 78 of the S12CPUV2
behavior branch_cond(out u1 ok) 
  select
    -- Unary branches
    case #RA do ok := 1 end do
    case #RN do ok := 0 end do
    -- Simple branches
    case #CC do ok := CCR.C = 0 end do
    case #CS do ok := CCR.C = 1 end do
    case #EQ do ok := CCR.Z = 1 end do
    case #MI do ok := CCR.N = 1 end do
    case #NE do ok := CCR.Z = 0 end do
    case #PL do ok := CCR.N = 0 end do
    case #VC do ok := CCR.V = 0 end do
    case #VS do ok := CCR.V = 1 end do
    -- Unsigned branches
    case #HI do ok := (CCR.C + CCR.Z) = 0 end do
    case #LS do ok := (CCR.C + CCR.Z) = 1 end do
    -- Signed branches
    case #GE do ok := (CCR.N ^ CCR.V) = 0 end do
    case #GT do ok := (CCR.Z + (CCR.N ^ CCR.V)) = 0 end do
    case #LE do ok := (CCR.Z + (CCR.N ^ CCR.V)) = 1 end do
    case #LT do ok := (CCR.N ^ CCR.V) = 1 end do
  end select
end behavior

behavior branch #BRANCH 
  u1 ok
  s8 offset
  branch_cond(ok)
  imm8(offset)
  do 
    if (ok = 1) then PC := (u16)((s16)(PC) + offset) end if
  end do
end behavior

behavior long_branch #LG_BRANCH #inst18 
  u1 ok
  s16 offset
  branch_cond(ok)
  imm16(offset)
  do 
    if (ok = 1) then PC := (u16)((s16)(PC) + offset) end if
  end do
end behavior

behavior lda #LDA 
  u16 _add
  u8 op
  get_dyadic_operand_addr(_add)
  do 
    op := Mem.memRead8(_add)
    alu.set_NZV(op{7} cat op = 0 cat 0)
  end do
  put_reg8(op)
end behavior

behavior ldaimm #LDA 
  s8 imm
  imm8(imm)
  do alu.set_NZV(imm{7} cat imm = 0s cat 0) end do
  put_reg8((u8)(imm))
end behavior

behavior sta #STA 
  u16 _add
  u8 op
  get_dyadic_operand_addr(_add)
  get_reg8(op)
  do 
    Mem.memWrite8(_add,op)
    alu.set_NZV(op{7} cat op = 0 cat 0)
  end do
end behavior

behavior aba #ABA #inst18 
  do A := alu.add_8_half(A,B) end do
end behavior

behavior andcc #ANDCC 
  s8 imm
  imm8(imm)
  do CCR := CCR & (u8)(imm) end do
end behavior

behavior asld #ASLD 
  do D := alu.sl_16(D) end do
end behavior

behavior b_set_clr 
  u16 op_addr
  s8 mask
  imm8(mask)
  get_dyadic_operand_addr(op_addr)
  b_op(op_addr,(u8)(mask))
end behavior

behavior b_op(u16 addr, u8 mask) 
  u8 val
  do val := Mem.memRead8(addr) end do
  select
    case #BCLR do val := val & ~mask end do
    case #BSET do val := val | mask end do
  end select
  do 
    Mem.memWrite8(addr,val)
    CCR.N := val{7}
    CCR.Z := val = 0
    CCR.V := 0
 end do
end behavior

behavior set_clr_op(u8 val, s8 mask, s8 offset) 
  select
    case #BRCLR do 
      if (val & (u8)(mask)) = 0 then 
        PC := (u16)((s16)(PC) + offset) 
      end if
      end do
    case #BRSET do 
      if ((~val) & (u8)(mask)) = 0 then 
        PC := (u16)((s16)(PC) + offset) 
      end if 
      end do
  end select
end behavior

behavior br_set_clr 
  u16 _add
  s8 mask
  s8 offset
  u8 val
  imm8(mask)@mask
  imm8(offset)@rel
  get_dyadic_operand_addr(_add)
  do val := Mem.memRead8(_add) end do
  set_clr_op(val,mask,offset)
end behavior

behavior bsr #BSR 
  s8 offset
  imm8(offset)
  do 
    SP := SP - 2
    Mem.memWrite16(SP,PC)
    PC := (u16)((s16)(PC) + offset)
  end do
end behavior

behavior call_im #CALL #CALL_IMM 
  s16 offset
  s8  page
  imm16(offset)
  imm8(page)
  do 
    SP := SP - 3
    Mem.memWrite16((u16)(SP+1),PC)
    Mem.memWrite8(SP,PPAGE)
    PPAGE := (u8)(page)
    PC := (u16)(offset)
  end do
end behavior

behavior call_dir_am(out u16 _add) 
  select
    case Indexed_5bits_offset(_add)
    case Indexed_9bits_offset(_add)
    case Indexed_16bits_offset(_add)
    case Indexed_acc_offset(_add)
    case Auto_incremented(_add)
  end select
end behavior

behavior call_ind_am(out u16 _add) 
  select
    case Indexed_16bits_indirect(_add)
    case Indexed_acc_D_offset(_add)
  end select
end behavior

behavior call_dir 
  u16 _add
  s8  page
  call_dir_am(_add)
  imm8(page)
  do 
    SP := SP - 3
    Mem.memWrite16((u16)(SP+1),PC)
    Mem.memWrite8(SP,PPAGE)
    PPAGE := (u8)(page)
    PC := _add
  end do
end behavior

behavior call_ind 
  u16 _add
  s8  page
  call_ind_am(_add)
  imm8(page)
  do 
    page := (s8)(Mem.memRead8((u16)(_add + 2)))
    _add := Mem.memRead16(_add)
    SP := SP - 3
    Mem.memWrite16((u16)(SP+1),PC)
    Mem.memWrite8(SP,PPAGE)
    PPAGE := (u8)(page)
    PC := _add
  end do
end behavior

behavior call_xb #CALL #CALL_XB 
  select
    case call_dir()
    case call_ind()
  end select
end behavior

behavior cba #CBA #inst18 
  do u8 res res := alu.cmp_8(A,B) end do
end behavior

behavior comp16_imm
  u16 op1
  s16 op2
  get_reg16(op1)
  imm16(op2)
  do u16 res res := alu.cmp_16(op1,(u16)(op2)) end do
end behavior

behavior daa #DAA #inst18 
  do 
    u8 correction := 0
    if CCR.H = 1 | A{3..0} > 9 then
       correction := (u8)(correction + 6)
    end if
    if CCR.C = 1 | A{7..4} > 9 then
      correction := (u8)(correction + \x60)
      CCR.C := 1
    end if
    A := (u8)(A + correction)
    CCR.N := A{7}
    CCR.Z := A = 0
  end do
end behavior

behavior dbranch #DITBr 
  field s9 offset
  u1 ok
  u16 val
  get_DITReg(val)
  ditop(val)
  put_DITReg(val)
  ditcond(val,ok)
  do 
    if ok = 1 then
      PC := (u16)((s16)(PC) + offset)
    end if
  end do
end behavior

behavior ditop(out u16 val) 
  select
    case #DB do val := val - 1 end do
    case #TB 
    case #IB do val := (u16)(val + 1) end do
  end select
end behavior

behavior ditcond(u16 val, out u1 ok) 
  select
    case #EQ do ok := val = 0 end do
    case #NE do ok := val != 0 end do
  end select
end behavior

behavior get_DITReg (out u16 reg) 
  select
    case #A do reg := A end do
    case #B do reg := B end do
    case #D do reg := D end do
    case #X do reg := X end do
    case #Y do reg := Y end do
    case #S do reg := SP end do
  end select
end behavior

behavior put_DITReg (u16 reg) 
  select
    case #A do A := (u8)(reg) end do
    case #B do B := (u8)(reg) end do
    case #D do D := reg end do
    case #X do X := reg end do
    case #Y do Y := reg end do
    case #S do SP := reg end do
  end select
end behavior

behavior mono_operation16(u16 op, out u16 res) 
  select
    case #DE16 do res := op - 1 CCR.Z := res = 0 end do
    case #IN16 do res := (u16)(op + 1) CCR.Z := res = 0 end do
    case #INCW #inst18 #INH_AMW do res := alu.add_16_noC(op, 1) end do
    case #ASR16 #inst18 do res := alu.asr_16(op) end do
  end select
end behavior

behavior monadic16_reg_inst -- #INH_AMW
  u16 reg
  u16 res
  get_reg16(reg)
  mono_operation16(reg,res)
  put_reg16(res)
end behavior

behavior dst_mono_operation16(out u16 res) #CLRW #inst18
  do res := alu.clr_16() end do
end behavior

behavior dst_monadic16_reg_inst #INH_AMW
  u16 res
  dst_mono_operation16(res)
  put_reg16(res)
end behavior

behavior dst_monadic16_mem_inst 
  u16 _add
  u16 res
  get_mono_operand_addr(_add)
  dst_mono_operation16(res)
  do Mem.memWrite16(_add,res) end do
end behavior

behavior ediv #EDIV 
  do 
    u32 res
    res := alu.div_32_16(Y cat D, X)
    Y := res{31..16}
    D := res{15..0}
  end do
end behavior

behavior edivs #EDIVS #inst18
  do 
    u32 res
    res := alu.divs_32_16(Y cat D, X)
    Y := res{31..16}
    D := res{15..0}
  end do
end behavior

behavior emacs #EMACS #inst18 
  u16 _add
  ext_am(_add)
  do 
    u32 res
    u16 mop1
    u16 mop2
    u16 aop
    mop1 := Mem.memRead16(X)
    mop2 := Mem.memRead16(Y)
    aop := Mem.memRead16(_add)
    res := alu.emacs(mop1,mop2,aop)
    Mem.memWrite16(_add,res{31..16})
    Mem.memWrite16((u16)(_add+2),res{15..0})
  end do
end behavior

behavior emaxd #EMAXD #inst18 
  u16 _add
  xb_am(_add)
  do D := alu.max16(D,Mem.memRead16(_add)) end do
end behavior

behavior emaxm #EMAXM #inst18
  u16 _add
  xb_am(_add)
  do Mem.memWrite16(_add,alu.max16(D,Mem.memRead16(_add))) end do
end behavior

behavior emind #EMIND #inst18
  u16 _add
  xb_am(_add)
  do D := alu.min16(D,Mem.memRead16(_add)) end do
end behavior

behavior eminm #EMINM #inst18
  u16 _add
  xb_am(_add)
  do Mem.memWrite16(_add,alu.min16(D,Mem.memRead16(_add))) end do
end behavior

behavior emul #EMUL 
  do 
    u32 res
    res := alu.mul_16_16(D, Y)
    Y := res{31..16}
    D := res{15..0}
  end do
end behavior

behavior emuls #EMULS #inst18 
  do 
    u32 res
    res := alu.muls_16_16(D, Y)
    Y := res{31..16}
    D := res{15..0}
  end do
end behavior

behavior etbl #ETBL #inst18 
  u16 _add
  Indexed_5bits_offset(_add)
  do 
    u16 p1
    u16 p2
    p1 := Mem.memRead16(_add)
    p2 := Mem.memRead16((u16)(_add+2))
    D := alu.etbl(p1,B,p2)
  end do
end behavior

behavior fdiv #FDIV #inst18 
  do 
    u32 res
    res := alu.fdiv_16_16(D,X)
    D := res{15..0}
    X := res{31..16}
  end do
end behavior

behavior idiv #IDIV #inst18 
  do 
    u32 res
    res := alu.div_16_16(D,X)
    D := res{15..0}
    X := res{31..16}
  end do
end behavior

behavior idivs #IDIVS #inst18 
  do 
    u32 res
    res := alu.divs_16_16(D,X)
    D := res{15..0}
    X := res{31..16}
  end do
end behavior

behavior jump #JMP 
  u16 _add
  select
    case xb_am(_add)
    case ext_am(_add)
  end select
  do PC := _add end do
end behavior

behavior jsr #JSR 
  u16 _add
  select
    case dir_am(_add)
    case xb_am(_add)
    case ext_am(_add)
  end select
  do 
    SP := SP - 2
    Mem.memWrite16(SP,PC)
    PC := _add
  end do
end behavior

behavior ld16 #LD16 
  u16 _add
  u16 op
  get_dyadic_operand_addr(_add)
  do 
    op := Mem.memRead16(_add)
    --message "value \x",_add
    alu.set_NZV(op{15} cat op = 0 cat 0)
  end do
  put_reg16(op)
end behavior

behavior st16 #ST16 
  u16 _add
  u16 op
  get_dyadic_operand_addr(_add)
  get_reg16(op)
  do 
    alu.set_NZV(op{15} cat op = 0 cat 0)
    Mem.memWrite16(_add,op)
  end do
end behavior

behavior ld16imm #LD16 
  s16 imm
  imm16(imm)
  do 
    alu.set_NZV(imm{15} cat imm = 0s cat 0)
  end do
  put_reg16((u16)(imm))
end behavior


behavior lea_am(out u16 _add) 
  select
    case Indexed_5bits_offset(_add)
    case Indexed_9bits_offset(_add)
    case Indexed_16bits_offset(_add)
    case Indexed_acc_offset(_add)
  end select
end behavior

behavior lea #LEA 
  u16 _add
  lea_am(_add)
  put_reg16(_add)
end behavior

behavior lsrd #LSRD 
  do D := alu.lsr_16(D) end do
end behavior

behavior maxa #MAXA #inst18 
  u16 _add
  xb_am(_add)
  do A := alu.max8(A,Mem.memRead8(_add)) end do
end behavior

behavior incw #INCW #inst18
  u16 _add
  select
    case xb_am(_add)
    case ext_am(_add)
  end select
  do
    u16 val := Mem.memRead16(_add)
    val := alu.add_16_noC(val, 1)
    Mem.memWrite16(_add, val)
  end do
end behavior

behavior maxm #MAXM #inst18 
  u16 _add
  xb_am(_add)
  do Mem.memWrite8(_add,alu.max8(A,Mem.memRead8(_add))) end do
end behavior

behavior mina #MINA #inst18
  u16 _add
  xb_am(_add)
  do A := alu.min8(A,Mem.memRead8(_add)) end do
end behavior

behavior minm #MINM #inst18
  u16 _add
  xb_am(_add)
  do Mem.memWrite8(_add,alu.min8(A,Mem.memRead8(_add))) end do
end behavior

behavior mul #MUL 
  do 
    u16 res
    res := alu.mul_8_8(A,B)
    A := res{15..8}
    B := res{7..0}
  end do
end behavior

behavior NOP #NOP
end behavior 

behavior orcc #ORCC 
  s8 imm
  imm8(imm)
  do CCR := CCR | (u8)(imm) end do
end behavior

behavior push8 #PSH8 
  u8 reg
  select
    case #A do reg := A end do
    case #B do reg := B end do
    case #C do reg := CCR end do
  end select
  do SP := SP - 1 Mem.memWrite8(SP,reg) end do
end behavior

behavior push16 #PSH16 
  u16 reg
  select
    case #D do reg := D end do
    case #X do reg := X end do
    case #Y do reg := Y end do
  end select
  do SP := SP - 2 Mem.memWrite16(SP,reg) end do
end behavior

behavior pull8 #PUL8 
  u8 reg
  do reg := Mem.memRead8(SP) SP := (u16)(SP + 1) end do
  select
    case #A do A := reg end do
    case #B do B := reg end do
    case #C do CCR := reg end do
  end select
end behavior

behavior pull16 #PUL16 
  u16 reg
  do reg := Mem.memRead16(SP) SP := (u16)(SP + 2) end do
  select
    case #D do D := reg end do
    case #X do X := reg end do
    case #Y do Y := reg end do
  end select
end behavior

behavior rev #REV #inst18
end behavior

behavior revw #REVW #inst18
end behavior

behavior rtc #RTC 
  do 
    PPAGE := Mem.memRead8(SP)
    PC := Mem.memRead16((u16)(SP+1))
    SP := (u16)(SP + 3)
  end do
end behavior

behavior rti #RTI 
  do 
    CCR := Mem.memRead8(SP)
    B := Mem.memRead8((u16)(SP+1))
    A := Mem.memRead8((u16)(SP+2))
    X := Mem.memRead16((u16)(SP+3))
    Y := Mem.memRead16((u16)(SP+5))
    PC := Mem.memRead16((u16)(SP+7))
    SP := (u16)((u16)(SP + 9))
  end do
end behavior

behavior rts #RTS 
  do 
    PC := Mem.memRead16(SP)
    SP := (u16)(SP + 2)
  end do
end behavior

behavior sba #SBA 
  do A := alu.cmp_8(A,B) end do
end behavior

behavior stop #STOP #inst18 
  do 
    if CCR.S = 0 then
      SP := SP - 9
      Mem.memWrite16((u16)(SP+7),PC)
      Mem.memWrite16((u16)(SP+5),Y)
      Mem.memWrite16((u16)(SP+3),X)
      Mem.memWrite8((u16)(SP+2),A)
      Mem.memWrite8((u16)(SP+1),B)
      Mem.memWrite8(SP,CCR)
    end if
  end do
end behavior

behavior swi #SWI 
  do 
    SP := SP - 9
    Mem.memWrite16((u16)(SP+7),PC)
    Mem.memWrite16((u16)(SP+5),Y)
    Mem.memWrite16((u16)(SP+3),X)
    Mem.memWrite8((u16)(SP+2),A)
    Mem.memWrite8((u16)(SP+1),B)
    Mem.memWrite8(SP,CCR)
    CCR.I := 1
    PC := Mem.memRead16(\xFFF6)
  end do
end behavior

behavior tab #TAB #inst18 do B := A end do 
end behavior 
behavior tba #TBA #inst18 do A := B end do 
end behavior 

behavior tbl #TBL #inst18 
  u16 _add
  Indexed_5bits_offset(_add)
  do 
    u8 p1
    u8 p2
    p1 := Mem.memRead8(_add)
    p2 := Mem.memRead8((u16)(_add+1))
    A := alu.tbl(p1,B,p2)
  end do
end behavior

behavior trap #TRAP #inst18 
  field u8 trap_num
  do 
    SP := SP - 9
    Mem.memWrite16((u16)(SP+7),PC)
    Mem.memWrite16((u16)(SP+5),Y)
    Mem.memWrite16((u16)(SP+3),X)
    Mem.memWrite8((u16)(SP+2),A)
    Mem.memWrite8((u16)(SP+1),B)
    Mem.memWrite8(SP,CCR)
    CCR.I := 1
    PC := Mem.memRead16(\xFFF8)
  end do
end behavior

behavior wai #WAI 
  do 
    SP := SP - 9
    Mem.memWrite16((u16)(SP+7),PC)
    Mem.memWrite16((u16)(SP+5),Y)
    Mem.memWrite16((u16)(SP+3),X)
    Mem.memWrite8((u16)(SP+2),A)
    Mem.memWrite8((u16)(SP+1),B)
    Mem.memWrite8(SP,CCR)
  end do
end behavior

behavior get_reg8_et(out u8 reg) 
  select
    case #A do reg := A end do
    case #B do reg := B end do
    case #C do reg := CCR end do
  end select
end behavior

behavior get_reg8_exg(out u16 reg) 
  select
    case #A do reg := \b00000000 cat A end do
    case #B do reg := \b11111111 cat B end do
    case #C do reg := \b11111111 cat CCR end do
  end select
end behavior

behavior put_reg8_et(u8 reg) 
  select
    case #A do A := reg end do
    case #B do B := reg end do
    case #C do CCR := reg end do
  end select
end behavior

behavior exg_8_8 #EXG 
  u8 v1
  u8 v2
  get_reg8_et(v1)@src
  get_reg8_et(v2)@dst
  put_reg8_et(v1)@dst
  put_reg8_et(v2)@src
end behavior

behavior tfr_8_8 #TFR 
  u8 val
  get_reg8_et(val)@src
  put_reg8_et(val)@dst
end behavior

behavior get_reg16_et(out u16 reg) 
  select
    case #TMP3 do reg := TMP3 end do
    case #TMP2 do reg := TMP2 end do
    case #D    do reg := D end do
    case #X    do reg := X end do
    case #Y    do reg := Y end do
    case #S    do reg := SP end do
  end select
end behavior

behavior put_reg16_et(u16 reg) 
  select
    case #TMP3 do TMP3 := reg end do
    case #TMP2 do TMP2 := reg end do
    case #D    do D := reg end do
    case #X    do X := reg end do
    case #Y    do Y := reg end do
    case #S    do SP := reg end do
  end select
end behavior

behavior exg_16_16 #EXG 
  u16 v1
  u16 v2
  get_reg16_et(v1)@src
  get_reg16_et(v2)@dst
  put_reg16_et(v1)@dst
  put_reg16_et(v2)@src  
end behavior

behavior tfr_16_16 #TFR 
  u16 val
  get_reg16_et(val)@src
  put_reg16_et(val)@dst
end behavior

behavior exg_8_16 #EXG 
  u16 v1
  u16 v2
  get_reg8_exg(v1)@src
  get_reg16_et(v2)@dst
  put_reg16_et(v1)@dst
  put_reg8_et(v2{7..0})@src
end behavior

-- a revoir
behavior tfr_8_16 #TFR 
  u8 val
  get_reg8_et(val)@src
  put_reg16_et((u16)((s16)(val)))@dst
end behavior

behavior exg_16_8 #EXG 
  u16 v1
  u16 v2
  get_reg16_et(v1)@src
  get_reg8_exg(v2)@dst
  put_reg8_et(v1{7..0})@dst
  put_reg16_et(v2)@src
end behavior

-- a revoir
behavior tfr_16_8 #TFR 
  u16 val
  get_reg16_et(val)@src
  put_reg8_et(val{7..0})@dst
end behavior

behavior movb_imm #MOVB #inst18 
  s8 val
  u16 _add
  imm8(val)
  get_mono_operand_addr(_add)
  do Mem.memWrite8(_add,(u8)(val)) end do
end behavior

behavior movb_mem #MOVB #inst18 
  u8 val
  u16 src_add
  u16 dst_add
  get_mono_operand_addr(src_add)@SRC
  get_mono_operand_addr(dst_add)@DST
  do val := Mem.memRead8(src_add) Mem.memWrite8(dst_add,val) end do
end behavior

behavior movw_imm #MOVW #inst18 
  s16 val
  u16 _add
  imm16(val)
  get_mono_operand_addr(_add)
  do Mem.memWrite16(_add,(u16)(val)) end do
end behavior

behavior movw_mem #MOVW #inst18 
  u16 val
  u16 src_add
  u16 dst_add
  get_mono_operand_addr(src_add)@SRC
  get_mono_operand_addr(dst_add)@DST
  do val := Mem.memRead16(src_add) Mem.memWrite16(dst_add,val) end do
end behavior

timing allInstruction
  if read PPAGE then -- g
    add 1 cycle
  end if

  do 
    add instruction size cycle -- f, O, P
  end do

  select -- indirect access.
    case #IND_IDX_16B do add 1 cycle end do
    case
  end select

  if write PPAGE then -- n
    add 1 cycle
  end if

  if use Mem.memRead8()   then add 1 cycle end if -- r
  if use Mem.memRead16()  then add 1 cycle end if -- R
  if use Mem.memWrite8()  then add 1 cycle end if -- w
  if use Mem.memWrite16() then add 1 cycle end if -- W

  select -- branch
    case #BRANCH do -- PPP/P
      if jumpTaken then 
        add 2 cycle
      end if
      end do
    case #LG_BRANCH do -- OPPP/OPO
      if jumpTaken then 
        add 1 cycle
      end if
      end do
    case
  end select
  
end timing

}
-- vim:ft=hadl:ts=2:sw=2
